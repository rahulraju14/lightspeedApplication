/**
 * File: AuthNetCheckoutServlet.java
 */
package com.lightspeedeps.checkout;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hibernate.FlushMode;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.orm.hibernate3.SessionFactoryUtils;
import org.springframework.orm.hibernate3.SessionHolder;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.web.context.support.WebApplicationContextUtils;

import com.lightspeedeps.dao.CheckoutOrderDAO;
import com.lightspeedeps.dao.CouponDAO;
import com.lightspeedeps.dao.ProductDAO;
import com.lightspeedeps.dao.ProductionDAO;
import com.lightspeedeps.dao.UserDAO;
import com.lightspeedeps.message.DoNotification;
import com.lightspeedeps.message.HttpUtils;
import com.lightspeedeps.model.CheckoutOrder;
import com.lightspeedeps.model.Coupon;
import com.lightspeedeps.model.Product;
import com.lightspeedeps.model.Production;
import com.lightspeedeps.model.User;
import com.lightspeedeps.type.EventType;
import com.lightspeedeps.type.OrderStatus;
import com.lightspeedeps.util.app.ApplicationUtils;
import com.lightspeedeps.util.app.Constants;
import com.lightspeedeps.util.app.EventUtils;
import com.lightspeedeps.util.app.ServiceFinder;
import com.lightspeedeps.web.production.CreateProductionBean;

/**
 * This class handles the asynchronous call-back (via HTTP post) from
 * authorize.net. The main purpose is to create the Production which the user
 * has now purchased. Most of the processing is in the
 * {@link #doAuthPost(HttpServletRequest, int, boolean)} method. That method may
 * also be called from the {@link com.lightspeedeps.web.production.ReceiptReturnBean},
 * when the authorize.net payment page does the HTTP Get to switch the user from the
 * Authorize.net domain back to us.
 * <p>
 * In most cases, doAuthPost() will get called twice for the same order, once
 * from the ReceiptReturnBean, and once from the doPost() method here in
 * response to the asynchronous post from Authorize.net. We simply check the
 * database and only process the first request for any given invoice number.
 */
public class AuthNetCheckoutServlet extends HttpServlet {
	private static final Log log = LogFactory.getLog(AuthNetCheckoutServlet.class);
	private static final long serialVersionUID = 1L;

	/** callback from authorize.net "silent post" */
	private static final int CALLBACK_TYPE_POST = 1;
	/** callback from payment page when user clicks "return to LS" */
	public static final int CALLBACK_TYPE_RETURN = 2;
	/** callback from authorize.net for a recurring subscription payment */
	private static final int CALLBACK_TYPE_SUBSCRIPTION = 3;

	/**
	 * The normal entry point for the HTTP post from Authorize.net.
	 * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
	 */
	@Override
	public void doPost(HttpServletRequest request, HttpServletResponse response) {
		log.debug("");
		doAuthPost(request, CALLBACK_TYPE_POST, true);
		sendOk(response);
	}

	/**
	 * Process a posting from authorize.net. This can create the Production
	 * purchased by a user.
	 *
	 * @param request The ServletRequest containing all the parameters passed
	 * 			  from authorize.net that describe the purchase just completed.
	 * @param type This is used to differentiate between a call from the POST
	 *            routine, called by authorize.net's "Silent URL" facility, and
	 *            a call from our own JSP page, resulting from the user clicking
	 *            the "return to lightspeed" link on the receipt page. type=1 is
	 *            from a POST, type=2 is from the receipt page link.
	 * @param needSession True iff this routine needs to establish a Hibernate
	 *            session. Currently, this is true for the POST call, and false
	 *            for the receipt link call (since it is processed through the
	 *            normal JSP lifecycle, and already has a session established).
	 */
	public static void doAuthPost(HttpServletRequest request, int type, boolean needSession) {
		SessionFactory sessionFactory = null;
		try {
			String msg = "Request parameters:" + Constants.NEW_LINE + formatParams(request);
			log.debug(msg);
			/** Transaction id generated by authorize.net */
			String transId = request.getParameter("x_trans_id");
			/** Authorize.net Transaction type */
			String transType  = request.getParameter("x_type");
			/** Invoice number, generated by LS (in CreateProductionBean.setupCheckout()) */
			String invoiceNum = request.getParameter("x_invoice_num");
			/** Authorize.net response code; will be '1' for successful transaction. */
			String responseCode = request.getParameter("x_response_code");
			/** Purchaser's LightSPEED account number. */
			String account = request.getParameter("x_cust_id");
			/** SKU of product just purchased. */
			String sku = request.getParameter("product_sku");
			/** Name of the production, set by user before purchase */
			String prodName = request.getParameter("production_name");
			/** Amount of the purchase/charge */
			String amount  = request.getParameter("x_amount");
			BigDecimal price = BigDecimal.ZERO;
			if (amount != null) {
				price = new BigDecimal(amount);
			}
			/** The coupon code entered by the user, if any. */
			String couponCode = request.getParameter("coupon_code");
			/** Subscription id, supplied by Authorize.net for a (recurring) subscription. The
			 * invoice number ("x_invoice_num") will be the same as the original purchase. */
			String subscriptionId = request.getParameter("x_subscription_id");
			/** The subscription payment number, sequential, origin 1. */
			String subscriptionPaynum = request.getParameter("x_subscription_paynum");


			// for a resubscribe, we'll have a production id
			Integer prodId = null;
			String prodIdStr = request.getParameter("production_id");
			if (prodIdStr != null && prodIdStr.trim().length() > 0) {
				try {
					prodId = Integer.parseInt(prodIdStr);
				}
				catch (Exception e) {
					log.error("Unexpected parse exception on production id: " + prodIdStr, e);
				}
			}
			log.debug("invoice #" + invoiceNum + ", acct #" + account + ", sku: " + sku +
					", production: " + prodName + ", coupon: " + couponCode);

			if (subscriptionId != null) {
				type = CALLBACK_TYPE_SUBSCRIPTION;
				log.debug("recurring subscription, id: " + subscriptionId + ", payment number: " + subscriptionPaynum);
			}

			ApplicationContext appContext = WebApplicationContextUtils.getRequiredWebApplicationContext(
					request.getSession().getServletContext());

			ServiceFinder.setRequestContext(appContext); // make it available for bean-finding
			ApplicationUtils.setRequestContext(request.getSession().getServletContext());

			if (needSession) {
				try {
					sessionFactory = (SessionFactory)ServiceFinder.findBean("sessionFactory");
					Session session = SessionFactoryUtils.getSession(sessionFactory, true);
					session.setFlushMode(FlushMode.AUTO);
					TransactionSynchronizationManager.bindResource(
							sessionFactory, new SessionHolder(session));
				}
				catch (Exception e) {
					log.error("bind exception: ", e);
				}
			}

			CheckoutOrderDAO orderDAO = CheckoutOrderDAO.getFromApplicationContext(appContext);
			CheckoutOrder order = null;
			boolean first = false;
			if (invoiceNum != null) {
				first = ! orderDAO.existsInvoiceNumberPrefix(invoiceNum); // first post for this order?
				String invoiceNumTyped = invoiceNum +  "-" + type;
				if (type == CALLBACK_TYPE_SUBSCRIPTION) {
					invoiceNumTyped += "-" + subscriptionPaynum;
				}
				order = orderDAO.findByInvoiceNumber(invoiceNumTyped);
				if (order == null) {
					order = new CheckoutOrder();
					order.setInvoiceNumber(invoiceNumTyped);
				}
				order.setDate(new Date());
				order.setTransactionId(transId);
				order.setTransactionType(transType);
				order.setAccountNumber(account);
				order.setSku(sku);
				order.setAmount(price);
				order.setOrderSummary(streamParams(request));
				log.debug("data len=" + order.getOrderSummary().length());
				orderDAO.attachDirty(order);
			}

			boolean done = false;
			Production production = null;
			if (account != null && sku != null && prodName != null && responseCode.equals("1")) {
				if (first) { // First post for this order
					UserDAO userDAO = UserDAO.getInstance();
					User user = userDAO.findOneByProperty(UserDAO.ACCOUNT_NUMBER, account);
					if (user != null) {
						Product product = ProductDAO.getInstance().findOneByProperty(ProductDAO.SKU, sku);
						if (product != null) {
							ProductDAO.getInstance().evict(product); // so it won't be updated in db
							product.setPrice(price); // use transaction amount for Production billing
							ProductionDAO prDAO = ProductionDAO.getFromApplicationContext(appContext);
							DoNotification notify = DoNotification.getInstance(appContext);
							Coupon coupon = null;
							if (couponCode != null && couponCode.length() > 0) {
								couponCode = couponCode.trim().toUpperCase(); // just in case
								coupon = CouponDAO.getInstance().findOneByProperty(CouponDAO.CODE, couponCode);
							}
							if (prodId != null) { // resubscribe or upgrade
								boolean upgrade = false;
								production = prDAO.findById(prodId);
								if (production != null) {
									if (production.getOrderStatus() == OrderStatus.FREE) {
										upgrade = true;
										production.setSku(sku);
										production.setMaxProjects(product.getMaxProjects());
										production.setMaxUsers(product.getMaxUsers());
									}
									production.setTransactionId(transId);
									prDAO.resubscribe(production, product);
									if (upgrade) {
										notify.productionUpgraded(production, user);
									}
									else {
										notify.productionResubscribed(production, user);
									}
								}
								else {
									log.error("Missing production for resubscribe/upgrade: " + prodId);
								}
							}
							else {
								if (coupon != null) {
									CreateProductionBean.applyDiscount(coupon, product);
									product.setPrice(price); // use transaction amount for Production billing
								}
								production = prDAO.create(account, product, prodName, user, transId);
								if (production != null) {
									notify.productionCreated(production, user);
									notify.productionUpgraded(production, user); // so it stands out in audit emails as $Paid$ ction/*-*/
								}
							}
							if (production != null && order != null) {
								order.setProductionId(production.getProdId());
								orderDAO.attachDirty(order);
								if (coupon != null) {
									updateCoupon(coupon, order);
								}
								prodId = production.getId();
							}
							done = true;
						}
						else {
							log.error("Product entry not found for transaction; SKU: " + sku);
						}
					}
					else {
						log.error("User entry not found for transaction; acct#: " + account);
					}
				}
				else {
					log.debug("Ignoring duplicate posting for order #" + invoiceNum);
					done = true;
				}
			}
			else if (type == CALLBACK_TYPE_SUBSCRIPTION && responseCode.equals("1")) {
				// subscription callback - nothing to do except record it, which we already did.
				done = true;
			}

			if (done) {
				msg = "Authorize.net charge processed: invoice #" + invoiceNum +
						", amount: $" + amount + ", acct #" + account;
				if (type == CALLBACK_TYPE_SUBSCRIPTION) {
					msg += "; recurring subscription, id: " + subscriptionId + ", payment #: " + subscriptionPaynum;
				}
				else {
					msg += ", sku: " + sku +
							", production: " + prodName + ", coupon: " + couponCode;
					if (prodId != null) { // resubscribe or upgrade
						msg += ", prod Id: " + prodId;
					}
				}
				EventUtils.logEvent(EventType.INFO, production, null, "", msg);
			}
			else {
				msg = "Authorize.net Post - charge failed; Parameters:" + Constants.NEW_LINE + formatParams(request);
				msg += Constants.NEW_LINE + "local IP=" + request.getLocalAddr() + ", remote IP=" + request.getRemoteAddr();
				EventUtils.logEvent(EventType.DATA_ERROR, null, null, "", msg);
			}

			ServiceFinder.setRequestContext(null); // context may be invalid shortly
			ApplicationUtils.setRequestContext(null);
		}
		catch (Exception e) {
			EventUtils.logError(e);
		}
		finally {
			if (sessionFactory != null) {
				try {
					SessionHolder sessionHolder = (SessionHolder)TransactionSynchronizationManager
							.unbindResource(sessionFactory);
					SessionFactoryUtils.releaseSession(sessionHolder.getSession(), sessionFactory);
				}
				catch (Exception e) {
					log.error("unbind failed: ", e);
				}
			}
		}
	}

	/**
	 * Update our coupon table to record that a coupon code was redeemed as part
	 * of this transaction.
	 *
	 * @param coupon The coupon used for the purchase.
	 * @param order The CheckoutOrder that contains the transaction details.
	 */
	private static void updateCoupon(Coupon coupon, CheckoutOrder order) {
		if (coupon != null) {
			coupon.setTimesUsed((short)(coupon.getTimesUsed()+1));
			coupon.setProdId(order.getProductionId());
			coupon.setRedeemerAcct(order.getAccountNumber());
			coupon.setRedeemed(new Date());
			CouponDAO.getInstance().attachDirty(coupon);
		}
	}

	private static String streamParams(HttpServletRequest request) {
		OutputStream byteStream = new ByteArrayOutputStream();
		try {
			ObjectOutputStream out;
			out = new ObjectOutputStream(byteStream);
			out.writeObject(request.getParameterMap());
			out.close();
		}
		catch (IOException e) {
			log.error("exception: ", e);
		}
		return byteStream.toString();
	}

	/**
	 * Created a printable representation of all the parameters passed as part
	 * of the given request.
	 *
	 * @param request The HttpServletRequest whose parameters are to be
	 *            formatted.
	 * @return A non-null String containing the names and values of all the
	 *         parameters in the given request, in ascending alphabetical order
	 *         of the parameter names.
	 */
	private static String formatParams(HttpServletRequest request) {
		return HttpUtils.formatParams(request);
	}

	private void sendOk(HttpServletResponse response) {
		response.setContentType("text/html");
		try {
			PrintWriter out = response.getWriter();
			response.setStatus(HttpServletResponse.SC_OK);
			out.println("<HTML><HEAD></HEAD><BODY>ok</BODY></HTML>");
			out.flush();
			out.close();
		}
		catch (IOException e) {
			log.error("exception: ", e);
		}
	}

	/**
	 * This can be used for testing the authorize.net "silent URL" facility, by
	 * entering the full URL with all the purchase parameters, on a browser's
	 * input field.
	 */
	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		log.debug("");
		doAuthPost(request, 2, true);

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">");
		out.println("<HTML>");
		out.println("  <HEAD><TITLE>Authorize.Net servlet</TITLE></HEAD>");
		out.println("  <BODY>");
		out.print("    Hello from Lightspeed AuthNetCheckoutServlet!");
		out.println("  </BODY>");
		out.println("</HTML>");
		out.flush();
		out.close();
	}

}
