package com.lightspeedeps.web.timecard;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.*;

import javax.faces.application.FacesMessage;
import javax.faces.component.UIData;
import javax.faces.event.*;
import javax.faces.model.SelectItem;

import org.apache.commons.logging.*;
import org.json.*;

import com.lightspeedeps.dao.*;
import com.lightspeedeps.model.*;
import com.lightspeedeps.service.*;
import com.lightspeedeps.type.*;
import com.lightspeedeps.util.app.*;
import com.lightspeedeps.util.common.StringUtils;
import com.lightspeedeps.util.payroll.*;
import com.lightspeedeps.web.approver.*;
import com.lightspeedeps.web.login.AuthorizationBean;
import com.lightspeedeps.web.onboard.*;
import com.lightspeedeps.web.popup.*;
import com.lightspeedeps.web.user.ChangePinBean;
import com.lightspeedeps.web.util.*;
import com.lightspeedeps.web.view.ListView;

/**
 * Superclass for the IndivTimecardBean, FullTimecardBean, and
 * MobileTimecardBean classes, which are the backing beans for the "basic",
 * "full", and several mobile timecard pages. This class is designed to
 * encapsulate all the code common to those pages, such as Edit, Save, Submit,
 * Approve, Reject, and data validation.
 */
public class TimecardBase extends ListView implements Disposable {
	/** */
	private static final long serialVersionUID = - 6852355714239104992L;

	private static final Log log = LogFactory.getLog(TimecardBase.class);

	/** Prefix for message ids, for messages and dialog box text generated by superclasses. */
	public static final String TIMECARD_MESSAGE_PREFIX = "Timecard.";

	// Mini-tabs on Timecards/My Timecards pages - both BASIC and FULL views!

	/** Index of the Timecard (main info) mini-tab on Timecards/My Timecards page. */
	public static final int TAB_MAIN = 0;
	/** Index of the Box Rental mini-tab on Timecards/My Timecards page. */
	public static final int TAB_BOX = 1;
	/** Index of the Mileage form mini-tab on Timecards/My Timecards page. */
	public static final int TAB_MILES = 2;
	/** Index of the Attachment mini-tab on Timecards/My Timecards page. */
	public static final int TAB_TC_ATTACHMENTS = 3;
	/** Index of the Audit trail mini-tab on Timecards/My Timecards page. */
	public static final int TAB_AUDIT = 4; // Audit tab only displayed on Full view

	private static final int ACT_SUBMIT = 11;
	private static final int ACT_APPROVE = 12;
	private static final int ACT_REJECT = 13;
	private static final int ACT_SUBMIT_APPROVE = 14;
	protected static final int ACT_RECALL = 15;
	private static final int ACT_PRINT = 16;
	protected static final int ACT_DELETE_IMAGE = 17;
	protected static final int ACT_DELETE_MILEAGE = 18;
	protected static final int ACT_DELETE_MILEAGE_ENTRY = 19; // only used for mobile
	protected static final int ACT_DELETE_BOX_RENTAL = 20;
	private static final int ACT_PULL = 21;
	private static final int ACT_CLONE = 22;
	private static final int ACT_VOID = 23;
	protected static final int ACT_COPY_WEEK = 24; // only used for mobile
	protected static final int ACT_UPDATE_TC = 25; // update timecard from start form
	protected static final int ACT_DELETE_EXPENSE_ENTRY = 26;
	private static final int ACT_RECALL_TO_EMPL = 27;
	private static final int ACT_ATTACH = 28;
	private static final int ACT_ACK_APPROVE = 29;


	protected static final int SUBMIT_OK = 0;
	protected static final int SUBMIT_FAILED_NO_APPROVER = 1;
	protected static final int SUBMIT_FAILED = 2;
	protected static final int SUBMIT_FAILED_SUBMITTED = 3;
	protected static final int SUBMIT_FAILED_DELETED = 4;

	/** The list of state code`s for the user to select from for standard timecards
	 * (TV, Feature, Commercial (but not hybrid). Excludes "HM", and includes "FO" choice
	 * (from database).  LS-1491, LS-1591, LS-2470 moved for commonly used in IndivTimecardBean and FulltimecardBean */
	private static final List<SelectItem> STATE_LIST_STD;

	private boolean displayCities = false;


	static {
		STATE_LIST_STD = new ArrayList<>(ApplicationScopeBean.getInstance().getStateCodeDL(Constants.DEFAULT_COUNTRY_CODE));
		//  (LS-4129 HM removed from db list; db is 'normal' state list including "FO")
	}

	/** The list of state code`s for the user to select from; different for
	 * "touring/hybrid" timecards using standard Day types (not touring types).  LS-2470 */
	private static final List<SelectItem> STATE_LIST_HYBRID;

	static {
		STATE_LIST_HYBRID = new ArrayList<>(STATE_LIST_STD);
		Iterator<SelectItem> iter = STATE_LIST_HYBRID.iterator();
		for (; iter.hasNext();) {
			SelectItem item = iter.next();
			if (item.getLabel().equals(Constants.FOREIGN_FO_STATE)) {
				// remove "FO" for hybrid productions. LS-2470
				// (LS-4129: HM removed from db list)
				iter.remove();
			}
		}
		STATE_LIST_HYBRID.add(Constants.FOREIGN_OT_STATE_ITEM); // Add "OT" for hybrids. LS-2221
	}

	/** The list of state code`s for the user to select from, modified for
	 * "touring/hybrid" timecards using Touring Day Types, to have "HM" & "OT" entries first. LS-1491 & LS-2161 & LS-2470 */
	private static final List<SelectItem> STATE_LIST_TOUR;

	static {
		STATE_LIST_TOUR = new ArrayList<>(STATE_LIST_STD);
		// Remove the OT state that is included with the
		// Standard state list so it is not added twice. LS-2161
		Iterator<SelectItem> iter = STATE_LIST_TOUR.iterator();
		for (; iter.hasNext();) {
			SelectItem item = iter.next();
			if (item.getLabel().equals(Constants.FOREIGN_FO_STATE)) {
				// remove "FO" for tours-hybrid. LS-2221
				iter.remove();
			}
		}
		STATE_LIST_TOUR.add(1, Constants.TOURS_HOME_STATE_ITEM); // "HM"
		STATE_LIST_TOUR.add(2, Constants.FOREIGN_OT_STATE_ITEM); // "OT"
	}

	/** The list of "state codes" for the user to "select" from for Day types where the
	 * state is being forced to either "HM" or "OT" and disabled.  We need these values
	 * to be in the list so they are displayed in Edit mode (even though disabled). LS-2331 & LS-2470*/
	private static final List<SelectItem> STATE_LIST_HM_OT;

	static {
		STATE_LIST_HM_OT = new ArrayList<>(2);
		STATE_LIST_HM_OT.add(Constants.TOURS_HOME_STATE_ITEM); // "HM"
		STATE_LIST_HM_OT.add(Constants.FOREIGN_OT_STATE_ITEM); // "OT"
	}

	/** True iff the user has not entered a Production; this normally means
	 * the user is on the "My Timecards" page. */
	private boolean notInProduction;

	/** The Production whose timecards are being displayed.  This will be the
	 * same as the current Production if the user has entered a Production,
	 * otherwise (for the My Timecards page) it will be a Production selected
	 * by the user, or null if no Production has been selected yet. */
	private Production viewProduction;

	/** The database id of the viewProduction. This is used as the target
	 * in the productionList drop-down selection. */
	private Integer viewProductionId;

	/** The Project whose timecards are being displayed. For non-Commercial
	 * productions, this will be null, as the Project is not relevant. For
	 * Commercial productions, this will null for an employee viewing their own
	 * timecard(s), or for a financial admin; for others (typically an
	 * approver), this will be the current Project. */
	private Project viewProject;

	/** For a Commercial production, the current Project -- the same as
	 * SessionUtils.currentProject. For a TV/Feature (non-Commercial)
	 * production, this will be null. This differs from viewProject in that the
	 * viewProject will be null in a Commercial Production if the current user
	 * has cross-project (aggregate) viewing privileges. */
	private Project commProject;

//	/** Occupation list contains SelectItem objects for occupation/role drop-down
//	 * in the top area of the Individual and Full Timecard pages. */
//	private List<SelectItem> occupationList;

	/** A reference to the session-scoped AuthorizationBean, used in determining
	 * a user's timecard-related permissions. */
	protected final AuthorizationBean authBean;

	/** True iff the current user is the next Approver for the currently displayed
	 * WeeklyTimecard. */
	private boolean mayApprove;

	/** True iff the current user is in the approval chain for the currently displayed
	 * WeeklyTimecard. */
	private boolean approvalAuth;

	/** True iff the current user has Edit authority for the currently displayed
	 * WeeklyTimecard.  For a timecard that is OPEN or has been REJECTED to the
	 * employee, the employee, time-keeper, and all approvers have edit authority.
	 * For any other timecard, only the current Approver has edit authority, and
	 * then only if they have edit-HTG permission. */
	private boolean editAuth;

	/** True iff the current user has the authority to clone the current timecard.
	 * This is typically true for any approver or for the department's timeKeeper. */
	private boolean cloneAuth;

	/** True iff the current user has 'pull' capability with respect to the
	 * currently displayed timecard. A person who is in the approval chain and
	 * has edit-HTG permission, but has not yet approved it, has this authority.
	 * Also, the timecard must have been submitted already (may not be in OPEN
	 * status). */
	private boolean pullAuth;

	/** True iff the current user has 'recall' capability with respect to the
	 * currently displayed timecard.  A person who has already approved the timecard
	 * has this capability, unless the timecard was Rejected back to an approver
	 * earlier in the chain than the current user. */
	private boolean recallAuth;

	/** True iff we are in edit mode and the current user is allowed to edit the
	 * "raw hours" fields, which are only available to the employee, his time-keeper,
	 *  or one of his approvers. It is set whenever editMode is changed. */
	protected boolean editRaw;

	/** True iff the current user has Edit_HTG permission, and we are in Edit mode.
	 * It is set whenever editMode is changed. */
	private boolean editHtg;

	/** True iff the current User/Contact has the edit_htg permission. */
	private boolean userHasEditHtg;

	/** True iff the current User/Contact has the view_htg permission. */
	private boolean userHasViewHtg;

	/** True iff the current User/Contact has the view_all_projects permission. */
	protected boolean userHasViewAllProjects;

	/** True iff the current user has the permission to view "private" data.  A user has
	 * this permission if they have either View-HTG or Edit-HTG rights, or if the
	 * current timecard is their own. */
	private boolean showPrivate = true;

	/** True iff the "copy prior week" button should be displayed.  This is displayed
	 * in edit mode if the prior week's timecard exists, and has non-zero hours. The
	 * value will be null if it has not been calculated for the current timecard. */
	private Boolean showCopyPrior;

	/** True if the "change PIN" dialog should be displayed. */
	private boolean showChangePin;

	/** Maintains the reason we put up the change-pin (really New pin) dialog,
	 * which should be either for Submit or Approve actions. */
	private int changePinReason;
	private final static int PIN_REASON_SUBMIT = 1;
	private final static int PIN_REASON_APPROVE = 2;

	/** True if the "Reject" dialog should be displayed. */
	private boolean showReject;

	/** True if the "Clone" dialog should be displayed. */
	private boolean showClone;

	/** The instance of the WeeklyTimecard currently being displayed or edited
	 * on the Individual or Full Time Card page. */
	protected WeeklyTimecard weeklyTimecard;

	/** The FormModelRelease which is associated with this timecard, if any. LS-4664 */
	private FormModelRelease modelRelease;

	/** The user whose timecard we are displaying or editing. */
	protected User tcUser;

	/** The database id of the user whose timecard we are displaying or editing
	 * ('tcUser'). Used in the JSP as the value of the drop-down list selection
	 * on the Individual Timecard page. */
	protected Integer userId;

	/** Database id of the Mileage form, if it was deleted by the user. */
	protected Integer deletedMileageId;

	/** Database id of the Box Rental form, if it was deleted by the user. */
	protected Integer deletedBoxId;

	/** Name of the next approver for the current timecard, if any. */
	private String approverName;

	/** Email address of the next approver for the current timecard, if any. */
	private String approverEmail;

	/** Screen field for user to enter a new comment. */
	private String newComment;

	/** Screen field for user to enter a new comment. */
	private String newPrivateComment;

	/** Screen field for user to enter a new comment on the Box Rental form. */
	private String newBoxComment;

	/** Screen field for user to enter a new comment on the Mileage form. */
	private String newMileageComment;

	/** Message saying who submitted the current timecard. */
	private String submitMsg;

	/** For the Mileage list, the index of the entry whose "delete" icon
	 * was clicked. */
	private int deleteMileageIx;

	/** The List of database ids of Mileage table line entries that
	 * have been deleted by the user in the current edit session. */
	private final List<Integer> deletedMiles = new ArrayList<>();

	// Fields for Expense table

	/** The expense category last selected from the drop-down list in the
	 * Expense/Reimbursement table.  Not used, except referenced by JSP. */
	PayCategory expCategory;

	/** The index (origin 0) of the entry in the Expenses table
	 * to be deleted. Set by the JSP when the user clicks a red X icon
	 * in an expense detail line. */
	private int deleteExpenseIx;

	/** Contents of the drop-down selection list for "Category" in the
	 * Expense/Reimbursement table */
	private List<SelectItem> expCategoryDL;

	/** Contents of the drop-down selection list for "Category" in the
	 * Expense/Reimbursement table for employees (on Basic TC page). */
	private List<SelectItem> emplExpCategoryDL;

	/** Copied from the StartForm, true if the Start has daily touring
	 * rates (in additional to 'normal' hourly rates).  LS-1347 */
	private boolean hasTouringRates;

	/** List of Day Types (for drop-down) provided when the relevant StartForm
	 * has the setting "hasTouringRates" specified.  LS-1347*/
	private static List<SelectItem> dayTypeToursList;

	/**
	 * List of Day Types (for drop-down) provided for non-union timecards
	 * LS-2010
	 */
	private static List<SelectItem> dayTypeNonUnionList;

	/** List of DayType`s for Hybrid production if Start does NOT have touring rates. LS-2160 */
	private static List<SelectItem> dayTypeHybridList;

	/** List of DayType`s for Hybrid production if Start has touring rates. LS-2160 */
	private static List<SelectItem> dayTypeHybridToursList;

	/** List of DayType`s for exempt, non-union, Team clients; adds "HOA". LS-2189*/
	private List<SelectItem> dayTypeExemptList;

	/**
	 * List of Day Types (for drop-down) provided for model timecards
	 * LS-4589
	 */
	private static List<SelectItem> dayTypeModelList;

	// Fields for Create Timecard pop-up

	/** True iff the Create Timecard pop-up should be displayed. */
	private boolean showCreate;

	/** Database id of the selected StartForm from the occupation drop-down
	 * on the Create Timecard pop-up. */
	private Integer startFormId;

	/** The occupation drop-down list for the Create Timecard pop-up, based
	 * on existing Start Forms for the user. */
	private List<SelectItem> occupationDL;

	/** The week-ending date selection list for the Create Timecard pop-up. */
	private List<SelectItem> weekEndDateDL;

	/** A week-ending date; used for selection on the Create Timecard pop-up,
	 * and for display on the Full Timecard page. */
	private Date weekEndDate;

	/** The last day of the week on a weekly timecard for the current production
	 * or project. Defaults to Saturday (=7); Sunday = 1. */
	protected Integer weekEndDay;

	private transient WeeklyTimecardDAO weeklyTimecardDAO;

	private transient ProductionDAO productionDAO;

	private final Disposer disposer = Disposer.getInstance();

	/** The list of Events of currently selected Timecard. */
	List<TimecardChangeEvent> timecardEventList = null;

	private boolean acknowledgeApprove = false;

	/** The AttachmentBean instance . */
	private transient AttachmentBean attachmentbean;

	/** True iff the current production uses the Team payroll service. */
	private Boolean isTeamPayroll;

	/** Whether the payroll service associated with this timecard is TEAM */
	protected Boolean teamPayroll;

	/** True if a Model Release form is associated with this timecard. LS-4651 */
	private Boolean useModelRelease;

	/** True if the "paid as" field is required to be set on the timecard. LS-2737 */
	protected boolean checkPaidAs;

	/** True iff the current production is 'hybrid': Commercial with
	 * the "include touring rates" option on. */
	private Boolean isHybridProduction;

	static {
		// initialize DayType list that is touring Day types only.  LS-1347
		dayTypeToursList = new ArrayList<>();
		dayTypeToursList.addAll(EnumList.getDayTypeList());
		// Initialize DayType list that is Hybrid Day types only. LS-2160
		dayTypeHybridList = new ArrayList<>();
		dayTypeHybridList.add(0, Constants.EMPTY_SELECT_ITEM);
		// Initialize DayType list that is Hybrid + Touring Day types. LS-2160
		dayTypeHybridToursList = new ArrayList<>();
		// initialize DayType list that includes for non-union timecards, LS-2010
		dayTypeNonUnionList = new ArrayList<>();
		dayTypeNonUnionList.add(0, Constants.EMPTY_SELECT_ITEM);
		// initialize DayType list that includes for model timecards, LS-4589
		dayTypeModelList = new ArrayList<>();
		dayTypeModelList.add(0, Constants.EMPTY_SELECT_ITEM);

		for (DayType dt : DayType.values()) {
			if (dt.isTours()) { // note that the first "Tours" day type is "--"
				dayTypeToursList.add(new SelectItem(dt, dt.toString()));
				dayTypeHybridToursList.add(new SelectItem(dt, dt.toString()));
			}
			else {
				if (dt.isNonUnion()) { //LS-2010
					dayTypeNonUnionList.add(new SelectItem(dt, dt.toString()));
				}
				if(dt.isHybrid()) { // LS-2160
					dayTypeHybridList.add(new SelectItem(dt, dt.toString()));
				}
				if (dt.isModelRelease()) {
					dayTypeModelList.add(new SelectItem(dt, dt.toString()));
				}
			}
		}

		// Combine hybrid and tours Day Types.
		dayTypeHybridToursList.addAll(0, dayTypeHybridList);
	}

	/**
	 * Our only constructor.
	 * @param sortKey The default sort key (column) to use for the 'main' list.
	 */
	public TimecardBase(String sortKey) {
		super(sortKey, TIMECARD_MESSAGE_PREFIX); // set list default sort-key and message prefix
		log.debug("");
		disposer.register(this);
		authBean = AuthorizationBean.getInstance();
		userHasEditHtg = authBean.hasPageField(Constants.PGKEY_EDIT_HTG);
		userHasViewHtg = authBean.hasPageField(Constants.PGKEY_VIEW_HTG);
		if (! SessionUtils.isMobileUser()) {
			userHasViewAllProjects = authBean.hasPageField(Constants.PGKEY_ALL_PROJECTS);
		}
		checkPaidAs = FF4JUtils.useFeature(FeatureFlagType.TTCO_ENHANCED_LOAN_OUT); // LS-2737

		viewProduction = SessionUtils.getNonSystemProduction();
		if (viewProduction == null) {
			notInProduction = true; // outside of a Production, e.g., on My Timecards page or mobile
			viewProductionId = SessionUtils.getInteger(Constants.ATTR_VIEW_PRODUCTION_ID);
			if (viewProductionId == null || viewProductionId == 0) {
				viewProduction = null;
				viewProductionId = 0;
			}
			else {
				viewProduction = ProductionDAO.getInstance().findById(viewProductionId);
			}
		}
		else {
			viewProductionId = viewProduction.getId();
		}

		// Set viewProject & commProject
		if (viewProduction != null) {
			if (viewProduction.getType().hasPayrollByProject() // Commercial
					&& ! notInProduction) {	// inside production (not in "My Timecards")
				commProject = SessionUtils.getCurrentProject();
				if (! userHasViewAllProjects) {
					// allow Financial Admin ability to see all projects (leave viewProject null)
					viewProject = commProject;
				}
			}

		}

		initTimecardFromSession();
		if (SessionUtils.getInteger(Constants.ATTR_TIMECARD_VIEW) == null) {
			SessionUtils.put(Constants.ATTR_TIMECARD_VIEW, 0);
		}
		getAttachmentBean().setDefaultAttachment(null, weeklyTimecard);
		// LS-2643 Show warning msg when there is no attachment for expenses;
		// session param needed because Save causes page refresh.
		if (SessionUtils.getBoolean(Constants.ATTR_EXPENSE_WITHOUT_ATTACHMENT, false)) {
			MsgUtils.addFacesMessage("Timecard.NoAttachment.ExpensesWarning",FacesMessage.SEVERITY_ERROR);
			SessionUtils.put(Constants.ATTR_EXPENSE_WITHOUT_ATTACHMENT, null);
		}
	}

	/**
	 * Check for a session variable indicating which WeeklyTimecard should be
	 * displayed. If the variable exists, set the matching timecard as the
	 * current one, IF it belongs to the current production.
	 */
	protected void initTimecardFromSession() {
		Integer id = SessionUtils.getInteger(Constants.ATTR_TIMECARD_ID);
		if (id != null) { // Have a specific time card to view
			setWeeklyTimecard(getWeeklyTimecardDAO().findById(id));
			if (weeklyTimecard != null) {
				if (viewProduction == null || ! weeklyTimecard.getProdId().equals(viewProduction.getProdId())) {
					// User is in a production, but the timecard Id from the session doesn't match this production
					weeklyTimecard = null;
					SessionUtils.put(Constants.ATTR_TIMECARD_ID, null);
				}
				else if (viewProject != null &&
						! weeklyTimecard.getStartForm().getProject().equals(viewProject)) {
					// Commercial production, & last viewed TC is not in the same project
					weeklyTimecard = null;
					SessionUtils.put(Constants.ATTR_TIMECARD_ID, null);  // clear this as default TC
					SessionUtils.put(Constants.ATTR_TC_TCUSER_ID, null); // flush default displayed user, too
					SessionUtils.put(Constants.ATTR_CONTACT_ID, null);
				}
				else {
					hasTouringRates = weeklyTimecard.getStartForm().getHasTourRates(); // LS-1347
				}
			}
			else {
				// clear session info as default TC, since it doesn't exist.
				SessionUtils.put(Constants.ATTR_TIMECARD_ID, null); // LS-1304
			}
		}
	}

	/**
	 * Clear session variables related to our display; this should be done when exiting
	 * My Timecards, before "entering" an actual production.
	 */
	public static void clearSession() {
		SessionUtils.put(Constants.ATTR_TIMECARD_ID, null);  // clear this as default TC
		SessionUtils.put(Constants.ATTR_TC_TCUSER_ID, null); // clear default displayed user, too
		SessionUtils.put(Constants.ATTR_CONTACT_ID, null);
		SessionUtils.put(Constants.ATTR_VIEW_PRODUCTION_ID, null); // clear selected production
	}

	/**
	 * Initialize superclass data, if any. This method is called by the
	 * subclasses after construction is complete.
	 */
	protected void setupUserChanged(User user) {
		if (user != null) {
			userId = user.getId();
		}
//		occupationList = null; // force creation if needed
		if (user != null &&
				(userHasViewHtg || user.getId().equals(getvUser().getId()) )) {
			showPrivate = true;
		}
		else {
			showPrivate = false;
		}
	}

	/**
	 * Reference lazy-initialized fields to make sure they are available during
	 * the render phase.
	 */
	protected void forceLazyInit() {
		// may be overridden by subclasses
		if (editMode) {
			for (PayBreakdown pb : weeklyTimecard.getPayLines()) {
				pb.getCategory(); // forced reference
			}
			for (PayJob pj : weeklyTimecard.getPayJobs()) {
				pj.getAccountDtl();
				for (PayJobDaily pjd : pj.getPayJobDailies()) {
					pjd.getDate();
				}
			}
		}
		if (weeklyTimecard.getMileage() != null) {
			weeklyTimecard.getMileage().getMileageLines().size();
		}
		weeklyTimecard.getDailyTimes().size();
		weeklyTimecard.getTimecardEvents().size();
		weeklyTimecard.getStartForm().getUnionLocalNum();
		weeklyTimecard.getStartForm().getContractSchedule();
		if (weeklyTimecard.getStartForm().getProject() != null) {
			weeklyTimecard.getStartForm().getProject().getTitle();
		}
		if (weeklyTimecard.getWeeklyBatch() != null) { // LS-1251
			weeklyTimecard.getWeeklyBatch().getName();
		}
		weeklyTimecard.getAttachments().size(); // LS-847
		for (PayExpense pe : weeklyTimecard.getExpenseLines()) {
			pe.getQuantity();
		}
		if (commProject != null) {
			commProject = ProjectDAO.getInstance().refresh(commProject);
			commProject.getPayrollPref().getHourRoundingType();
			if (commProject.getApprover() != null) {
				commProject.getApprover().getContact();
			}
		}
		if (weeklyTimecard.getStartForm().getModelRelease() != null) { //LS-4589
			weeklyTimecard.getStartForm().setModelRelease(getModelRelease());
		}
		viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
	}

	/**
	 * Action method for the Edit button
	 * @see com.lightspeedeps.web.view.ListView#actionEdit()
	 */
	@Override
	public String actionEdit() {
		log.debug("");
		try {
			if (weeklyTimecard == null) { // some intervening event cleared this?
				log.warn("weeklyTimecard is null");
				return null;			// just ignore it
			}
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (this instanceof IndivTimecardBean) {
				updateItemInList(weeklyTimecard);	// make sure List instance is same as current one being saved
			}
			if (weeklyTimecard == null) {
				MsgUtils.addFacesMessage("Timecard.Edit.Deleted", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
			calculateApproverFlags(weeklyTimecard);

			if (FF4JUtils.useFeature(FeatureFlagType.TTCO_RESIDENT_COMMERCIAL_TIMECARDS)) {
				for (DailyTime dt : weeklyTimecard.getDailyTimes()) {
					cityDL(dt);
				}
			}
			if (! editAuth) {
				forceLazyInit();
				if (weeklyTimecard.getStatus() != ApprovalStatus.OPEN) {
					// not in employee's queue ... may be able to Pull or Recall it...
					if (pullAuth) {
						Integer appContactId = TimecardUtils.findApproverContactId(weeklyTimecard);
						if (appContactId != null && ! appContactId.equals(getvContact().getId())) {
							// current user is not the next approver
							// This is a "pull" action -- later approver taking TC from earlier approver
							if ( ! lockAndPrompt("")) {
								return null;
							}
							Contact appContact = ContactDAO.getInstance().findById(appContactId);
							PopupBean bean = PopupBean.getInstance();
							bean.show(this, ACT_PULL, getMessagePrefix() + "Pull.");
							String name = appContact.getUser().getFirstNameLastName();
							bean.setMessage(MsgUtils.formatMessage(
									getMessagePrefix() + "Pull.Text", name));
							return null;
						}
					}
					if (recallAuth) { // past approver, or employee/owner, may have this authority.
						// (note that current user could not be the next approver)
						boolean userOwnsTimecard = weeklyTimecard.getUserAccount().equals(
								getvUser().getAccountNumber());
						boolean didApprove = TimecardUtils.findDidApprove(weeklyTimecard, getvUser());
						if (userOwnsTimecard || didApprove) {
							// This is a "recall" action
							if ( ! lockAndPrompt("")) {
								return null;
							}
							PopupBean bean = PopupBean.getInstance();
							String msgPrefix = getMessagePrefix();
							String param;
							int action;
							if (didApprove) {
								// earlier approver recalling TC from later approver or final approved state
								msgPrefix += "Recall.";
								action = ACT_RECALL;
								param = tcUser.getFirstNameLastName();
							}
							else { // employee recalling TC from approver
								msgPrefix += "RecallToEmployee.";
								action = ACT_RECALL_TO_EMPL;
								SimpleDateFormat oSdf = new SimpleDateFormat(
										Constants.WEEK_END_DATE_FORMAT);
								param = oSdf.format(weeklyTimecard.getEndDate());
							}
							bean.show(this, action, msgPrefix);
							bean.setMessage(MsgUtils.formatMessage(msgPrefix + "Text", param));
							return null;
						}
					}
				}
				MsgUtils.addFacesMessage("Timecard.EditNotAllowed", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			return actionEditOk();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Continuation of entering edit mode, either immediately from actionEdit,
	 * or as a result of clicking OK on one of the Edit prompts, e.g., due to a
	 * Recall or Pull action being confirmed.  This method locks the timecard
	 * for editing, and updates transient total fields and various edit-level
	 * authorization flags.
	 *
	 * @return null navigation string
	 */
	protected String actionEditOk() {
		try {
			super.actionEdit();
			editRaw = false;
			editHtg = false;
			deletedMiles.clear();
			if (editMode && weeklyTimecard != null) {
				User currentUser = getvUser();
				if (! lockAndPrompt("")) {
					forceLazyInit();
					return null;
				}
				viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
				TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
				if (weeklyTimecard.getSubmitable()) { // OPEN or rejected to employee
					if (editAuth || weeklyTimecard.getUserAccount().equals(currentUser.getAccountNumber())) {
						editRaw = true;
						if (getApprovalAuth() && userHasEditHtg) {
							editHtg = true;
						}
					}
				}
				if (! editHtg) {
					if (getApprovalAuth() && userHasEditHtg) {
						editHtg = true;
					}
				}
				if (weeklyTimecard.getBoxRental() != null) {
					weeklyTimecard.getBoxRental().setInventory(StringUtils.editHtml(weeklyTimecard.getBoxRental().getInventory()));
				}
				calculateRoundingType();
				forceLazyInit();
				if (getModelRelease() != null) { //LS-4589
					TimecardCheck.allowModelReleaseFields(weeklyTimecard);
				}
				storeEventForTimecards(TimedEventType.EDIT, TimecardFieldType.N_A, -1, null);
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the OK button on the "Pull" confirmation dialog box.
	 * Change the approver to be the current user, then enter Edit mode.
	 *
	 * @return null navigation string
	 */
	private String actionPullOk() {
		weeklyTimecard = getWeeklyTimecardDAO().pull(weeklyTimecard, getvContact().getId());
		statusChanged(weeklyTimecard);
		return actionEditOk();
	}

	/**
	 * Action method for the OK button on the "Recall" confirmation dialog box
	 * when the timecard is being recalled to the current user (as an approver,
	 * not the employee). First, change the approver to the current user.
	 * Notifications will normally be issued during that step. After adjusting
	 * the timecard, enter Edit mode.
	 *
	 * @return null navigation string
	 */
	private String actionRecallOk() {
		weeklyTimecard = getWeeklyTimecardDAO().recall(weeklyTimecard, getvContact().getId());
		statusChanged(weeklyTimecard);
		return actionEditOk();
	}

	/**
	 * Action method for the OK button on the "Recall" confirmation dialog box,
	 * when the timecard is being recalled to the employee. First, change the
	 * approver to no approver (the timecard will be ready to submit again).
	 * Notifications will normally be issued during that step. After adjusting
	 * the timecard, enter Edit mode.
	 *
	 * @return null navigation string
	 */
	private String actionRecallToEmplOk() {
		weeklyTimecard = getWeeklyTimecardDAO().recall(weeklyTimecard, null);
		statusChanged(weeklyTimecard);
		return actionEditOk();
	}

	/**
	 * Action method for the "Save" button that saves weekly timecard
	 * and after save switches back to View mode
	 * @return null navigation string
	 */
	@Override
	public String actionSave() {
		try {
			log.debug("");
			if (TimecardCheck.validateAll(weeklyTimecard)) {
				if (this instanceof IndivTimecardBean) {
					updateItemInList(weeklyTimecard);	// make sure List instance is same as current one being saved
				}
				TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
				TimecardCalc.calculateOtherTotals(weeklyTimecard);
				//TimecardCalc.calculateAndCheckJobHours(weeklyTimecard);
				weeklyTimecard.setJobHoursDiffer(! TimecardCheck.validateJobHours(weeklyTimecard));
				// weeklyTimecard contains all updated values
				weeklyTimecard.setLockedBy(null); // unlock it
				// Update any missing required fields on Start from timecard info
				StartFormService.updateStartFormRequiredFields(weeklyTimecard);
				removeExtraPbLine(weeklyTimecard);
				for (Integer id : deletedMiles) {
					if (id > 0) {
						MileageLine mileageLine = MileageLineDAO.getInstance().findById(id);
						if (mileageLine != null) {
							getWeeklyTimecardDAO().delete(mileageLine);
						}
					}
				}
				deletedMiles.clear();
				if (deletedMileageId != null) {
					Mileage mileage = MileageDAO.getInstance().findById(deletedMileageId);
					getWeeklyTimecardDAO().delete(mileage);
					deletedMileageId = null;
				}
				if (deletedBoxId != null) {
					BoxRental boxRental = BoxRentalDAO.getInstance().findById(deletedBoxId);
					getWeeklyTimecardDAO().delete(boxRental);
					deletedBoxId = null;
				}
				if (weeklyTimecard.getBoxRental() != null) {
					weeklyTimecard.getBoxRental().setInventory(StringUtils.saveHtml(weeklyTimecard.getBoxRental().getInventory()));
				}
				weeklyTimecard.setUpdated(new Date());

				// For Team clients (payroll accountants) do Auto Pay on save, in case Pay Job info was updated.
				if (editHtg && weeklyTimecard.getPayJobs().size() > 0) {
					if (isTeamPayroll()) {
						getWeeklyTimecardDAO().removeDeletedPaylines(weeklyTimecard);
						weeklyTimecard = getWeeklyTimecardDAO().merge(weeklyTimecard); // Update to database
						TimecardService.autoPay(weeklyTimecard);
					}
				}
				if (editHtg) {
					getWeeklyTimecardDAO().removeDeletedPaylines(weeklyTimecard);
				}

				weeklyTimecard = getWeeklyTimecardDAO().merge(weeklyTimecard); // Update to database
				editHtg = false;	// returning to view mode
				editRaw = false;
				super.actionSave();
				storeEventForTimecards(TimedEventType.SAVE, TimecardFieldType.N_A, -1, null);
			}
			// LS-2643: Show warning msg when there is no attachment for certain expenses
			if(FF4JUtils.useFeature(FeatureFlagType.TTCO_EXPENSE_NO_ATTACHMENT)) {
				if (getSelectedTab() == TAB_MAIN && TimecardUtils.isExpenseWithoutAttach(weeklyTimecard)) {
					Set<Attachment> attachment = weeklyTimecard.getAttachments();
					if (attachment == null || attachment.isEmpty()) {
						SessionUtils.put(Constants.ATTR_EXPENSE_WITHOUT_ATTACHMENT, true);
					}
				}
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		addButtonClicked();
		return null;
	}

	/**
	 * Action method for the main (Edit) "Cancel" button. Also called via
	 * confirmCancel, for the Cancel buttons on several pop-up dialogs, such as
	 * Reject, Recall, and Pull. Restores the data from the current database
	 * image, ensures the timecard is unlocked, and returns to View mode.
	 *
	 * @return null navigation string
	 */
	@Override
	public String actionCancel() {
		try {
			deletedMiles.clear();
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (weeklyTimecard != null) { // may happen in delete-cancel scenario (TC deleted by other user)
				getWeeklyTimecardDAO().unlock(weeklyTimecard, getvUser().getId());
				TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
				TimecardCalc.calculateOtherTotals(weeklyTimecard);
				forceLazyInit();
				if (editMode) {
					storeEventForTimecards(TimedEventType.CANCEL, TimecardFieldType.N_A, -1, null);
				}
			}
			editRaw = false;
			editHtg = false;
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return super.actionCancel();
	}

	/**
	 * Action method for the Delete button. Verify the timecard is still in Open
	 * status, just in case someone else submitted it while we were viewing it.
	 *
	 * @see com.lightspeedeps.web.view.ListView#actionDelete()
	 */
	@Override
	public String actionDelete() {
		String res = null;
		try {
			actionCancel(); // turn off edit mode if necessary
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (weeklyTimecard == null) {
				MsgUtils.addFacesMessage("Timecard.Delete.Deleted", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			if (! weeklyTimecard.getStatus().equals(ApprovalStatus.OPEN)) {
				MsgUtils.addFacesMessage("Timecard.TimecardStatusNotOpen", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			if (! lockAndPrompt("Delete.")) {
				return null;
			}
			res = super.actionDelete();
			SimpleDateFormat oSdf = new SimpleDateFormat(Constants.WEEK_END_DATE_FORMAT);
			String dateStr = oSdf.format(weeklyTimecard.getEndDate());
			String message = MsgUtils.formatMessage("Timecard.Delete.Text", dateStr, tcUser.getFirstNameLastName());
			PopupBean.getInstance().setMessage(message);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return res;
	}

	/**
	 * Action method when the user clicks Cancel on the Delete prompt. We need
	 * to unlock the timecard, since we lock it when the user first clicks the
	 * Delete button.
	 *
	 * @return null navigation string
	 */
	private String actionDeleteCancel() {
		return actionCancel(); // this will refresh & unlock
	}

	/**
	 * Action method for the "Void" button. Locks the timecard and puts up a
	 * prompt to confirm the action.
	 *
	 * @return null navigation string
	 */
	public String actionVoid() {
		try {
			actionCancel();
			if (weeklyTimecard.getStatus().equals(ApprovalStatus.OPEN) ||
					weeklyTimecard.getStatus().equals(ApprovalStatus.LOCKED) ||
					weeklyTimecard.getStatus().equals(ApprovalStatus.VOID) ||
					weeklyTimecard.getTimeFinal() != null || /* payroll status is "final edit" */
					weeklyTimecard.getTimePaid() != null) {  /* payroll status is "paid" */
				// shouldn't actually be able to get here -- button should be hidden
				MsgUtils.addFacesMessage("Timecard.Void.StatusOpen", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			if (! lockAndPrompt("Void.")) {
				return null;
			}

			SimpleDateFormat oSdf = new SimpleDateFormat(Constants.WEEK_END_DATE_FORMAT);
			String dateStr = oSdf.format(weeklyTimecard.getEndDate());
			String message = MsgUtils.formatMessage("Timecard.Void.Text", dateStr, tcUser.getFirstNameLastName());

			CommentPinPromptBean bean = CommentPinPromptBean.getInstance();
			bean.show(this, ACT_VOID, getMessagePrefix()+"Void.");
			bean.setMessage(message);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for OK button on the "Void Timecard" pop-up. Mark the
	 * timecard as Void and add a Void event to it.
	 *
	 * @return null navigation string
	 */
	private String actionVoidOk() {
		try {
			actionCancel(); // to unlock
			CommentPinPromptBean bean = CommentPinPromptBean.getInstance();
			weeklyTimecard = getWeeklyTimecardDAO().voidStatus(weeklyTimecard, bean.getComment());
			statusChanged(weeklyTimecard);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action when user clicks Cancel on the "Void Timecard" dialog box. We need
	 * to unlock the timecard, since we lock it when the user first clicks the
	 * Void button.
	 *
	 * @return null navigation string
	 */
	private String actionVoidCancel() {
		return actionCancel(); // this will refresh & unlock
	}

	/**
	 * Action method for the Clone button. Results in displaying the
	 * "Clone Timecard" dialog.
	 *
	 * @return null navigation string
	 */
	public String actionClone() {
		log.debug("");
		try {
			if (weeklyTimecard == null) { // some intervening event cleared this?
				log.warn("weeklyTimecard is null");
				return null;			// just ignore it
			}
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (! lockAndPrompt("Clone.")) {
				forceLazyInit();
				return null;
			}
			CloneTimecardBean bean = CloneTimecardBean.getInstance();
			bean.show(this, ACT_CLONE, null, null, null);
			showClone = true;
			return null;
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Called via confirmOk when the clone operation has completed normally,
	 * and we are about to re-display our page without the dialog box.
	 * @return null navigation string
	 */
	private String actionCloneDone() {
		weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
		getWeeklyTimecardDAO().unlock(weeklyTimecard, getvUser().getId());
		TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
		TimecardCalc.calculateOtherTotals(weeklyTimecard);
		forceLazyInit();
		return null;
	}


	/**
	 * Method called for the "copy from prior" button, to copy last week's
	 * timecard data into the current timecard.  This only happens in Edit mode,
	 * and the changes are not saved in the database -- the changes will
	 * be saved when the user clicks Save.
	 *
	 * @return null navigation string
	 */
	public String actionCopyPrior() {
		try {
			log.debug("");
			if (weeklyTimecard == null) { // some intervening event cleared this?
				log.warn("weeklyTimecard is null");
				return null;			// just ignore it
			}
			Date priorDate = TimecardUtils.calculatePriorWeekEndDate(weeklyTimecard.getEndDate());
			Project tcProj = TimecardUtils.findProject(viewProduction, weeklyTimecard);
			List<WeeklyTimecard> priorTcs = getWeeklyTimecardDAO().findByWeekEndDateAccountOccupation(
					viewProduction, tcProj, priorDate, weeklyTimecard.getUserAccount(), weeklyTimecard.getOccupation());
			if (priorTcs.size() > 0) {
				WeeklyTimecard priorTc = priorTcs.get(0);
				TimecardUtils.copyEmpData(priorTc, weeklyTimecard, false, false);
				updateItemInList(weeklyTimecard);
			}
			else {
				MsgUtils.addFacesMessage("Timecard.PriorWeekNotFound", FacesMessage.SEVERITY_ERROR);
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}

		return null;
	}

	/**
	 * Method called after user hits "Ok" to confirm a "Delete" request. Deletes
	 * the weekly timecard.
	 *
	 * @return null navigation string
	 */
	@Override
	public String actionDeleteOk() {
		//If the status is Open
		try {
			log.debug("");
			actionCancel(); // refresh, unlock; exits Edit mode if in effect.
			if (weeklyTimecard.getStatus().equals(ApprovalStatus.OPEN)) {
				if (editMode) {
					editRaw = false;
					editHtg = false;
					super.actionCancel();
				}
				// Delete the timecard & related entities from the database
				storeEventForTimecards(TimedEventType.DELETE, TimecardFieldType.N_A, -1, weeklyTimecard.toString());
				getWeeklyTimecardDAO().remove(weeklyTimecard);
				setWeeklyTimecard(null);
				SessionUtils.put(Constants.ATTR_TIMECARD_ID, null); // LS-1304
				setSelectedRow(-1); // turn off selection
			}
			else {
				MsgUtils.addFacesMessage("Timecard.TimecardStatusNotOpen", FacesMessage.SEVERITY_ERROR);
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Submit" button. Prompts user for PIN/password.
	 * <p>
	 * If the current user is also the first approver and they are submitting
	 * their own timecard, we will generate an automatic approval event for the
	 * timecard in addition to the Submit event (once they OK the prompt). In
	 * this case, the prompt dialog also includes the option to change the next
	 * approver.
	 *
	 * @return null navigation string
	 */
	public String actionSubmit() {
		try {
			log.debug("");
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (weeklyTimecard == null) {
				MsgUtils.addFacesMessage("Timecard.Submit.Deleted", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
//2.9.5599	TimecardUtils.updateBoxRentalExpense(weeklyTimecard, false, true);
			if (weeklyTimecard.getApproverId() != null) {
				//log.warn("Attempt to submit a timecard that was already submitted!");
				MsgUtils.addFacesMessage("Timecard.Submit.Submitted", FacesMessage.SEVERITY_ERROR);
				statusChanged(weeklyTimecard);
				return null;
			}
			Project tcProj = TimecardUtils.findProject(viewProduction, weeklyTimecard);
			if (! ApproverUtils.existsApprover(weeklyTimecard.getDepartment(), weeklyTimecard.getProdId(), tcProj)) {
				PopupBean.getInstance().show(null, 0,
						"Timecard.NoApprovers.Title",
						"Timecard.NoApprovers.Text",
						"Confirm.OK", null); // no cancel button
				forceLazyInit();
				return null;
			}
			StartForm sf = weeklyTimecard.getStartForm();
			Date lastDate = TimecardUtils.calculatePriorWeekEndDate(weeklyTimecard.getEndDate());
			// Check both sf.getEarliestEndDate and employment.endDate for expiration
			log.debug("");
			sf = StartFormDAO.getInstance().refresh(sf);
			if (sf.getEmployment() != null) {
				sf.setEmployment(EmploymentDAO.getInstance().refresh(sf.getEmployment()));
				if ((sf.getEmployment().getEndDate() != null &&
						(! sf.getEmployment().getEndDate().after(lastDate))) ||
						(sf.getEarliestEndDate() != null && (! sf.getEarliestEndDate().after(lastDate)))) {
					MsgUtils.addFacesMessage("Timecard.Submit.OutOfDate", FacesMessage.SEVERITY_ERROR);
					return null;
				}
			}
			if (! weeklyTimecard.getHasRequiredFields(checkPaidAs)) { // LS-2737
				if (! TimecardService.updateTimecardRequiredFields(weeklyTimecard)) {
					// LS-2727 & LS-2734 put up team specific message for Team clients.
					String bodyTextId = "Timecard.TimecardNotComplete.Text";
					if(isTeamPayroll()) {
						bodyTextId = "Timecard.TimecardNotCompleteTeam.Text";
					}
					PopupBean.getInstance().show(null, 0,
							"Timecard.TimecardNotComplete.Title",
							bodyTextId,
							"Confirm.OK", null); // no cancel button
					forceLazyInit();
					return null;
				}
			}
			// Update any missing required fields on Start from timecard info
			StartFormService.updateStartFormRequiredFields(weeklyTimecard);
			User currUser = SessionUtils.getCurrentUser(); // Note: don't use vUser, it may be stale!
			if (currUser.getPin() == null) {
				showChangePin = true;
				changePinReason = PIN_REASON_SUBMIT;
				ChangePinBean.getInstance().show(this);
				addFocus("pin");
				return null;
			}
			if (! lockAndPrompt("Submit.")) {
				forceLazyInit();
				return null;
			}
			String name = tcUser.getFirstNameLastName();
			if (currUser.equals(tcUser)) {
				log.debug("SUBMIT AND APPROVE");
				Contact appCon = TimecardUtils.findNextApproverContact(weeklyTimecard);
				if (appCon != null && currUser.equals(appCon.getUser()) &&
						(ApproverUtils.isDeptApprover(appCon, tcProj, weeklyTimecard.getDepartment()) ||
								ApproverUtils.isProjectApprover(appCon, tcProj))) {
					// first approver = submitter; treat as approval to allow re-direct option
					ApprovePromptBean bean = ApprovePromptBean.getInstance();
//					if (currUser.equals(tcUser)) {
						bean.showPin(this, ACT_SUBMIT_APPROVE, getMessagePrefix()+"PinSubmitApproveSelf.", weeklyTimecard);
//					}
//					else {
//						bean.showPin(this, ACT_SUBMIT_APPROVE, getMessagePrefix()+"PinSubmitApproveOther.", weeklyTimecard);
//						bean.setMessage(MsgUtils.formatMessage(getMessagePrefix()+"PinSubmitApproveOther.Text", name));
//					}
					bean.setMultipleApprovers(false);
					bean.setApproverContactId(TimecardUtils.findNextNextApproverContactId(weeklyTimecard));
					addFocus("approve");
					return null;
				}
			}
			if (currUser.equals(tcUser)) {
				PinPromptBean bean = PinPromptBean.getInstance();
				bean.promptPin(this, ACT_SUBMIT,
						getMessagePrefix()+"PinSubmitSelf.");
				addFocus("submit");
			}
			else {
				SubmitPromptBean bean = SubmitPromptBean.getInstance();
				bean.show(this, ACT_SUBMIT,
						getMessagePrefix()+"PinSubmitOther.", weeklyTimecard.getUnderContract());
				bean.setMessage(MsgUtils.formatMessage(getMessagePrefix()+"PinSubmitOther.Text", name));
				addFocus("submitOther");
			}
			return null;
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the Cancel button on the Submit dialog. We need to
	 * unlock the timecard, which was locked when we put up the dialog box.
	 *
	 * @return null navigation string
	 */
	public String actionSubmitCancel() {
		return actionCancel(); // this will refresh & unlock
	}

	/**
	 * Method called when user hits "ok/e-sign" on the Submit, or Submit &
	 * Approve, dialog box. Update the timecard's status appropriately, and set
	 * the next-approver id.
	 *
	 * @param approve True iff this is called via the "submit & approve" dialog
	 *            box.
	 * @return true iff the submit was successful.
	 */
	protected boolean actionSubmitOk(boolean approve) {
		boolean bRet = false;
		try {
			TimecardSubmitType subType = null;
			String comment = null;
			User currUser = getvUser();
			if (! currUser.equals(tcUser)) {
				SubmitPromptBean bean = SubmitPromptBean.getInstance();
				subType = bean.getSubmitType();
				if (subType == TimecardSubmitType.OTHER) {
					comment = bean.getComment();
				}
			}
			int ret = submit(approve, subType, comment);
			switch (ret) {
				case SUBMIT_OK:
					// If this production has been set to calculate timecards on submission, the
					// calculation will have been done in WeeklyTimecardDAO.submit. (LS-2245)
					// This flag is set on the Production Admin Payroll Service page.

					if (subType == null || subType == TimecardSubmitType.NORMAL) {
						MsgUtils.addFacesMessage("Timecard.Submit.Done", FacesMessage.SEVERITY_INFO);
					}
					else {
						MsgUtils.addFacesMessage("Timecard.SubmitOnBehalf.Done", FacesMessage.SEVERITY_INFO);
					}
					bRet = true;
					break;
				case SUBMIT_FAILED_NO_APPROVER:
					// This will only happen if the approver(s) were removed while the "Submit"
					// pop-up was being displayed, since we checked before we put up the pop-up.
					PopupBean.getInstance().show(null, 0,
							"Timecard.NoApprovers.Title",
							"Timecard.NoApprovers.Text",
							"Confirm.OK", null); // no cancel button
					break;
				case SUBMIT_FAILED:
					MsgUtils.addFacesMessage("Timecard.Submit.Failed", FacesMessage.SEVERITY_ERROR);
					break;
				case SUBMIT_FAILED_SUBMITTED:
					MsgUtils.addFacesMessage("Timecard.Submit.Submitted", FacesMessage.SEVERITY_ERROR);
					break;
				case SUBMIT_FAILED_DELETED:
					MsgUtils.addFacesMessage("Timecard.Submit.Deleted", FacesMessage.SEVERITY_ERROR);
					break;
			}
			if (weeklyTimecard != null) { // will be null if timecard was deleted by someone else
				statusChanged(weeklyTimecard);
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return bRet;
	}

	/**
	 * Performs the overall process of getting a timecard submitted. This
	 * includes a number of validity checks, updating totals, and calling the
	 * DAO method to update the timecard to Submitted status.
	 *
	 * @param approve True iff this is called via the "submit & approve" dialog
	 *            box.
	 * @param subType The "submit type" which indicates, for example, if the
	 *            timecard was submitted by other than the employee, and if so,
	 *            why (e.g., a paper timecard was submitted).
	 * @param comment A comment is required when a timecard is submitted by a
	 *            person other than the employee, and the reason was not one of
	 *            the "standard" ones available by selection.
	 * @return A code indicating if the submit was successful, and, if not, the
	 *         reason for the failure. The reason codes are defined as final
	 *         statics in this class.
	 */
	/* package */ int submit(boolean approve, TimecardSubmitType subType, String comment) {
		int ret = SUBMIT_OK;
		weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
		if (weeklyTimecard == null) {
			log.warn("Attempt to submit a timecard that was deleted!");
			return SUBMIT_FAILED_DELETED;
		}
		getWeeklyTimecardDAO().unlock(weeklyTimecard, getvUser().getId());
		TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
		// make sure Box Rental expense matches timecard & StartForm data
		TimecardUtils.updateExpenseItems(weeklyTimecard, false, true);
		TimecardCalc.calculateOtherTotals(weeklyTimecard);
		if (weeklyTimecard.getApproverId() != null || weeklyTimecard.getStatus().isFinal()) {
			log.warn("Attempt to submit a timecard that was already submitted!");
			return SUBMIT_FAILED_SUBMITTED;
		}
		if (subType != null) {
			if (subType == TimecardSubmitType.PAPER_SIGNATURE) {
				weeklyTimecard.setSignedPaper(true);
			}
			else if (subType == TimecardSubmitType.OTHER) {
				TimecardUtils.addComment(weeklyTimecard, comment);
			}
		}
		WeeklyTimecard wtc = getWeeklyTimecardDAO().submit(weeklyTimecard, approve, subType);
		if (wtc != null) { // ok
			weeklyTimecard = wtc;
		}
		else {
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			// distinguish between no approvers or other error
			Production prod = TimecardUtils.findProduction(weeklyTimecard);
			Project tcProj = TimecardUtils.findProject(prod, weeklyTimecard);
			if (ApproverUtils.findFirstApprover(prod, tcProj, weeklyTimecard.getDepartment(), null) == null) {
				// This will only happen if the approver(s) were removed while the "Submit"
				// pop-up was being displayed, since we checked before we put up the pop-up.
				ret = SUBMIT_FAILED_NO_APPROVER;
			}
			else {
				ret = SUBMIT_FAILED;
			}
		}

		return ret;
	}

	/**
	 * Perform the "Calc HTG" function on the current timecard, and persist
	 * it in the database.
	 */
	protected void calcAndSaveTimecard() {
		TimecardService.calculateAllHtg(weeklyTimecard, false, false); // this does not persist changes
		getWeeklyTimecardDAO().removeDeletedPaylines(weeklyTimecard);
		getWeeklyTimecardDAO().attachDirty(weeklyTimecard); // Update to database
	}

	/**
	 * Action method for the Approve button. Results in displaying either the
	 * "Set PIN" dialog or "Approve Timecard" dialog.
	 *
	 * @return null navigation string
	 */
	public String actionApprove() {
		try {
			log.debug("");
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if ((! acknowledgeApprove) && weeklyTimecard.getExpenseLines() != null &&
					(! weeklyTimecard.getExpenseLines().isEmpty()) &&
					(weeklyTimecard.getAttachments() == null || weeklyTimecard.getAttachments().isEmpty())) {
				//MsgUtils.addFacesMessage("Timecard.Attachment.ApproveWarning", FacesMessage.SEVERITY_WARN);
				log.debug("");
				PopupBean bean = PopupBean.getInstance();
				bean.show(this, ACT_ACK_APPROVE, "Timecard.Attachment.ApproveWarning.");
				return null;
			}
			User user = SessionUtils.getCurrentUser(); // don't use vUser, it may be stale
			if (user.getPin() == null) {
				showChangePin = true;
				changePinReason = PIN_REASON_APPROVE;
				ChangePinBean.getInstance().show(this);
				addFocus("pin");
				return null;
			}
//			boolean lockReqd = weeklyTimecard.getHtgLocked();
//			Integer id = SessionUtils.getCurrentContact().getId();
//			id = ApprovalHierarchyBean.findNextApproverId(weeklyTimecard.getDepartment(), id);
//			lockReqd |= (id == null); // if no "next approver", lock is required (this is final approval)
			Integer contactId = TimecardUtils.findNextApproverContactId(weeklyTimecard);
			ApprovePromptBean bean = ApprovePromptBean.getInstance();
			bean.showPin(this, ACT_APPROVE, getMessagePrefix()+"PinApproveOne.", weeklyTimecard);
			bean.setMultipleApprovers(false);
			bean.setApproverContactId(contactId);
			if (isTeamPayroll()) {
				// Check to see if there is any payment info missing that would prevent the
				// timecard from being calculated. If so put up a warning message.
				if (TimecardUtils.checkForMissingPaymentInfo(weeklyTimecard)) {
					bean.setAlertMessage(MsgUtils.getMessage("Approval.MissingPaymentInfo.1TC"));
				}
			}
			addFocus("approve");
			acknowledgeApprove = false;
			return null;
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Method for handling the "OK" button on the "Approve Timecard" dialog,
	 * called via the confirmOk() method.
	 *
	 * @return null navigation string
	 */
	private String actionApproveOk() {
		try {
			log.debug("");
			ApprovePromptBean bean = ApprovePromptBean.getInstance();
			Integer id = bean.getApproverContactId();
			WeeklyTimecard wtc = getWeeklyTimecardDAO().approve(weeklyTimecard, id);
			if (wtc == null) {
				MsgUtils.addFacesMessage("Approval.NotReady", FacesMessage.SEVERITY_ERROR);
				weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			}
			else {
				weeklyTimecard = wtc;
			}
			statusChanged(weeklyTimecard);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Reject" button. Displays the "Reject Timecard"
	 * dialog box.
	 *
	 * @return null navigation string
	 */
	public String actionReject() {
		log.debug("");
		try {
			showReject = true;
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
			forceLazyInit();
			if (! lockAndPrompt("Reject.")) {
				return null;
			}
			promptReject(weeklyTimecard, this, getMessagePrefix());
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Display the "Reject Timecard" dialog box.  Used from the Timecard
	 * pages and the Approval Dashboard page.
	 *
	 * @param wtc The WeeklyTimecard that is being rejected.
	 * @param holder The holding instance for the popup.
	 * @param prefix The prefix for message id's for messages generated in the
	 *            dialog box.
	 */
	public static void promptReject(WeeklyTimecard wtc, PopupHolder holder, String prefix) {
		RejectPromptBean bean = RejectPromptBean.getInstance();
		bean.show(holder, ACT_REJECT, prefix+"PinRejectOne.", wtc);
		String name = wtc.getFirstName() + " " + wtc.getLastName();
		bean.setMessage(MsgUtils.formatMessage(prefix+"PinRejectOne.Text", name));
		bean.setCommentMsg(MsgUtils.getMessage(prefix+"PinRejectOne.CommentMsg"));
		addFocus("reject");
	}

	/**
	 * Method to process the "OK" button being clicked on the "Reject Timecard"
	 * dialog. Called via the confirmOk() method; when called, the timecard
	 * should still be locked; the reject code will unlock it.
	 *
	 * @return null navigation string
	 */
	private String actionRejectOk() {
		try {
			showReject = false;
			RejectPromptBean bean = RejectPromptBean.getInstance();
			Integer approverId = bean.getSelectedApproverId();
			Integer contactId = bean.getSelectedContactId();
			weeklyTimecard = getWeeklyTimecardDAO().reject(weeklyTimecard, getvContact(),
					contactId, approverId, bean.getComment());
			statusChanged(weeklyTimecard);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for "Return" button - jump back to Approval dashboard
	 *
	 * @return Navigation string for Approval page
	 */
	public String actionReturn() {
		SessionUtils.put(Constants.ATTR_TIMECARD_ID, weeklyTimecard.getId());
		return HeaderViewBean.PAYROLL_APPROVER;
	}

	/**
	 * Action method for the "Add" button in the Comment section of the Full
	 * Timecard or Basic Timecard displays. Takes the comment input field, adds
	 * the user's name and a date/time stamp, and appends it all to the existing
	 * comment field. However, if the comment field is empty or only blanks, the
	 * action is ignored and the timecard's comment field is unchanged.
	 *
	 * @return null navigation string
	 */
	public String actionAddComment() {
		try {
			TimecardUtils.addComment(weeklyTimecard, newComment);
			newComment = "";
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method to add a comment to the Box Rental form.
	 * @return null navigation string
	 */
	public String actionAddBoxComment() {
		try {
			String comment = TimecardUtils.formatComment(newBoxComment);
			if (comment != null) {
				if (weeklyTimecard.getBoxRental().getComments() != null) {
					comment = weeklyTimecard.getBoxRental().getComments() + comment;
				}
				weeklyTimecard.getBoxRental().setComments(comment);
			}
			newBoxComment = "";
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method to add a comment to the Mileage form.
	 * @return null navigation string
	 */
	public String actionAddMileageComment() {
		try {
			String comment = TimecardUtils.formatComment(newMileageComment);
			if (comment != null) {
				if (weeklyTimecard.getMileage().getComments() != null) {
					comment = weeklyTimecard.getMileage().getComments() + comment;
				}
				weeklyTimecard.getMileage().setComments(comment);
			}
			newMileageComment = "";
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Add" button on the mileage form, which adds a new
	 * blank entry to the bottom of the mileage form. It sets the date to
	 * today's date.
	 *
	 * @return null navigation string
	 */
	public String actionAddMileage() {
		try {
			TimecardUtils.addMileageLine(weeklyTimecard);
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method called when the user clicks a "delete" icon next to one of
	 * the Mileage form entries. The deleteMileageIx field should be set already
	 * due to the f:setPropertyActionListener in the JSP.
	 *
	 * @return null navigation string
	 */
	public String actionDeleteMileageLine(ActionEvent event) {
		try {
			UIData data = (UIData)event.getComponent().findComponent("mileagelist");
			if(data != null) {
				int rowIndex = data.getRowIndex();
				Mileage mileage = weeklyTimecard.getMileage();

				if (mileage != null && rowIndex < mileage.getMileageLines().size()) {
					MileageLine m = mileage.getMileageLines().remove(rowIndex);
					if (m != null && m.getId() != null) {
						deletedMiles.add(m.getId());
					}
					weeklyTimecard.getMileage().setMiles(null); // force re-totaling
					StartForm sf = weeklyTimecard.getStartForm();
					sf = StartFormDAO.getInstance().refresh(sf);
					TimecardUtils.updateMileageExpense(weeklyTimecard);
				}
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Create form" on the Mileage mini-tab. Creates a
	 * new Mileage object and adds one blank line to it. The object is not saved
	 * until the user clicks Save on the timecard.
	 *
	 * @return null navigation string
	 */
	public String actionCreateMileageForm() {
		log.debug("");
		try {
			if (weeklyTimecard.getMileage() == null) {
				Mileage mileage = new Mileage(weeklyTimecard);
				weeklyTimecard.setMileage(mileage);
				actionAddMileage();	// put in a blank line
				forceLazyInit();
			}
			else {
				EventUtils.logError("Attempt to create a second Mileage form for the same timecard.");
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}


	/**
	 * Action method for the "Delete form" on the Mileage mini-tab.
	 * This does not remove the object from the database -- that won't
	 * happen until the user does a Save.
	 *
	 * @return null navigation string
	 */
	public String actionDeleteMileageForm() {
		try {
			if (weeklyTimecard.getMileage() != null) {
				PopupBean bean = PopupBean.getInstance();
				bean.show(this, ACT_DELETE_MILEAGE, getMessagePrefix()+"Delete.Mileage.");
				SimpleDateFormat oSdf = new SimpleDateFormat(Constants.WEEK_END_DATE_FORMAT);
				String dateStr = oSdf.format(weeklyTimecard.getEndDate());
				String message = MsgUtils.formatMessage("Timecard.Delete.Mileage.Text", dateStr);
				bean.setMessage(message);
			}
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Delete form" on the Mileage mini-tab.
	 * This does not remove the object from the database -- that won't
	 * happen until the user does a Save.
	 *
	 * @return null navigation string
	 */
	protected String actionDeleteMileageFormOk() {
		try {
			if (weeklyTimecard.getMileage() != null) {
				deletedMileageId = weeklyTimecard.getMileage().getId();
			}
			weeklyTimecard.setMileage(null);
			TimecardUtils.deletePayExpense(weeklyTimecard, PayCategory.MILEAGE_NONTAX);
			TimecardUtils.deletePayExpense(weeklyTimecard, PayCategory.MILEAGE_TAX);
			MsgUtils.addFacesMessage("Timecard.Mileage.Deleted", FacesMessage.SEVERITY_INFO);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Create form" on the Box Rental mini-tab.
	 * Creates a new BoxRental object attached to the current timecard. The
	 * object is not saved until the user clicks Save on the timecard.
	 *
	 * @return null navigation string
	 */
	public String actionCreateBoxRental() {
		log.debug("");
		try {
			if (weeklyTimecard.getBoxRental() == null) {
				BoxRental boxRental = new BoxRental(weeklyTimecard);
				weeklyTimecard.setBoxRental(boxRental);
				boxRental.setAmount(null);
				// Set amount in Box Rental to match Start Form
				StartForm sf = weeklyTimecard.getStartForm();
				sf = StartFormDAO.getInstance().refresh(sf);
				BigDecimal amount;
				if (weeklyTimecard.isStudioRate()) {
					amount = sf.getBoxRental().getStudio();
				}
				else {
					amount = sf.getBoxRental().getLoc();
				}
				boxRental.setAmount(amount);
				// We no longer create the Expense line at this time
	//2.9.5416	TimecardUtils.updateBoxRentalExpense(weeklyTimecard, false, false);
				forceLazyInit();
			}
			else {
				EventUtils.logError("Attempt to create a second BoxRental form for the same timecard.");
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the "Delete form" on the Box Rental mini-tab.
	 * This does not remove the object from the database -- that won't
	 * happen until the user does a Save.
	 *
	 * @return null navigation string
	 */
	public String actionDeleteBoxRental() {
		try {
			if (weeklyTimecard.getBoxRental() != null) {
				PopupBean bean = PopupBean.getInstance();
				bean.show(this, ACT_DELETE_BOX_RENTAL, getMessagePrefix()+"Delete.BoxRental.");
				SimpleDateFormat oSdf = new SimpleDateFormat(Constants.WEEK_END_DATE_FORMAT);
				String dateStr = oSdf.format(weeklyTimecard.getEndDate());
				String message = MsgUtils.formatMessage("Timecard.Delete.BoxRental.Text", dateStr);
				bean.setMessage(message);
			}
			addButtonClicked();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	protected String actionDeleteBoxRentalOk() {
		try {
			if (weeklyTimecard.getBoxRental() != null) {
				deletedBoxId = weeklyTimecard.getBoxRental().getId();
			}
			weeklyTimecard.setBoxRental(null);
			TimecardUtils.deletePayExpense(weeklyTimecard, PayCategory.BOX_RENT_NONTAX);
			TimecardUtils.deletePayExpense(weeklyTimecard, PayCategory.BOX_RENT_TAX);
			MsgUtils.addFacesMessage("Timecard.BoxRental.Deleted", FacesMessage.SEVERITY_INFO);
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for "copy to timecard" on the Box Rental form. This
	 * propagates the current amount from the Box Rental form into the
	 * timecard's Expense table, typically replacing the amount from the Start
	 * Form.
	 *
	 * @return null navigation string
	 */
	public String actionCopyBoxToExpenses() {
		try {
			if (weeklyTimecard.getBoxRental() != null) {
				if (TimecardCheck.validateBoxRental(weeklyTimecard.getBoxRental().getAmount())) {
					TimecardUtils.updateBoxRentalExpense(weeklyTimecard, true, false);
				}
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Action method for the red-X delete icons in the Expenses table.
	 * The 'deleteExpenseIx' field has already been set via the JSP.
	 * @return null navigation String
	 */
	public String actionDeleteExpenseLine(int ix) {
		log.debug("ix=" + ix);
		try {
			deleteExpenseIx = ix;
			PayExpense payExpense = weeklyTimecard.getExpenseLines().get(deleteExpenseIx);
			String categoryDescription = payExpense.getCategory();
			weeklyTimecard.getExpenseLines().remove(deleteExpenseIx);
//			if (exp.getId() != null) {
//				weeklyTimecard.getDeletedExpenseLines().add(exp);
//			}
			weeklyTimecard.calculateExpenses();	// recalculate grand total
			TimecardUtils.renumberExpenseLines(weeklyTimecard);  // just to be safe!
			if (weeklyTimecard != null) {
				log.debug("......................>>> DELETE_LINE event for Expenses");
				storeEventForTimecards(TimedEventType.CHANGE, TimecardFieldType.DELETE_LINE, deleteExpenseIx+1, categoryDescription);
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addFacesMessage("Generic.SystemError", FacesMessage.SEVERITY_ERROR);
		}
		return null;
	}

	/**
	 * Action method for the Print button.  Display the print options
	 * pop-up dialog.
	 * @return null navigation string
	 */
	public String actionPrint() {
		try {
			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (weeklyTimecard == null) { // someone else deleted the current timecard
				MsgUtils.addFacesMessage("Timecard.View.Deleted", FacesMessage.SEVERITY_ERROR);
				return null;
			}
			TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
			TimecardPrintUtils.showPrintOptions(weeklyTimecard, null, null, userHasViewHtg, cloneAuth, this, ACT_PRINT, false, false, false);
			forceLazyInit();
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * Print the timecards as requested by the user.
	 * @return null navigation string
	 */
	protected String actionPrintOk() {
		PrintTimecardBean bean = PrintTimecardBean.getInstance();
		//weeklyTimecard = WeeklyTimecardDAO.getInstance().refresh(weeklyTimecard);
		boolean skipAttachments = weeklyTimecard.getAttachments().isEmpty() || (! bean.getIncludeAttachments());
		String res = TimecardPrintUtils.printSelectedReport(weeklyTimecard, getViewProject(), (getViewProject()==null), skipAttachments, null);
		if (res == null) {
			MsgUtils.addFacesMessage("Timecard.View.Deleted", FacesMessage.SEVERITY_ERROR);
			weeklyTimecard = null;
		}
		return null;
	}

	/**
	 * Action method for uploading an Attachment.
	 * @return null navigation string.
	 */
	public String actionUploadAttachment() {
		log.debug("");
		if (weeklyTimecard != null && weeklyTimecard.getId() != null) {
			//weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (weeklyTimecard.getAttachments() != null &&
					weeklyTimecard.getAttachments().size() <= Constants.MAX_TC_ATTACHMENT) {
				PopupUploadBean uploadBean = PopupUploadBean.getInstance();
				uploadBean.show(this, ACT_ATTACH, "ContactFormBean.UploadAttachment.");
			}
			else {
				MsgUtils.addFacesMessage("Timecard.Attachment.MaxLimit", FacesMessage.SEVERITY_INFO);
			}
		}
		return null;
	}

	/**
	 * Action method called when the user hits Save on the Upload prompt dialog.
	 */
	private String actionUploadAttachmentOk(){
		try {
			log.debug("");
			PopupUploadBean uploadBean = PopupUploadBean.getInstance();
			String attachmentName = uploadBean.getDisplayFilename();
			// Get saved attactment.id value from bean
			Integer id = uploadBean.getAttachmentId();
			AttachmentDAO attachmentDAO = AttachmentDAO.getInstance();
			log.debug("attactment id = "+id);
			Attachment latestAttachment = attachmentDAO.findById(id);
			latestAttachment.setName(attachmentName);
			Map<String, Object> values = new HashMap<> ();
			values.put("name", attachmentName);
			values.put("weeklyTimecard", weeklyTimecard);
			if (attachmentDAO.findOneByNamedQuery(Attachment.GET_ATTACHMENT_BY_NAME_TIMECARD, values) != null) {
				uploadBean.setIsNameError(true);
				uploadBean.displayError("Duplicate Attachment Name.");
				return null;
			}
//			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			weeklyTimecard.getAttachments().add(latestAttachment);
			latestAttachment.setWeeklyTimecard(weeklyTimecard);
			latestAttachment.setIsPrivate(false); // not allowed
			attachmentDAO.attachDirty(latestAttachment);
			//weeklyTimecard = getWeeklyTimecardDAO().merge(weeklyTimecard);
			getWeeklyTimecardDAO().attachDirty(weeklyTimecard);
			if (latestAttachment.getMimeType().isPdf()) {
				attachmentDAO.convertToXod(id);
			}
			getAttachmentBean().setDefaultAttachment(null, weeklyTimecard);
			SessionUtils.put(Constants.ATTR_TIMECARD_ATTACHMENT_ID, id);
			getAttachmentBean().getAttachmentList();
			setSelectedTab(TAB_TC_ATTACHMENTS);
		}
		catch (Exception e) {
			EventUtils.logError("TimecardBase upload attachment failed Exception: ", e);
			MsgUtils.addGenericErrorMessage();
		}
		return null;
	}

	/**
	 * @see com.lightspeedeps.web.view.ListView#confirmOk(int)
	 */
	@Override
	public String confirmOk(int action) {
		String res = null;
		switch(action) {
			case ACT_DELETE_ITEM:
				res = actionDeleteOk();
				break;
			case ACT_SUBMIT:
				actionSubmitOk(false);
				break;
			case ACT_SUBMIT_APPROVE:
				actionSubmitOk(true);
				break;
			case ACT_APPROVE:
				res = actionApproveOk();
				break;
			case ACT_CLONE:
				actionCloneDone();
				break;
//			case 0-ACT_APPROVE:
//				res = actionApproveOk(false);
//				break;
			case ACT_REJECT:
				res = actionRejectOk();
				break;
			case ACT_RECALL:
				res = actionRecallOk();
				break;
			case ACT_RECALL_TO_EMPL:
				res = actionRecallToEmplOk();
				break;
			case ACT_PULL:
				res = actionPullOk();
				break;
			case ACT_PRINT:
				res = actionPrintOk();
				break;
			case ACT_DELETE_BOX_RENTAL:
				res = actionDeleteBoxRentalOk();
				break;
			case ACT_DELETE_MILEAGE:
				res = actionDeleteMileageFormOk();
				break;
			case ACT_VOID:
				actionVoidOk();
				break;
			case ChangePinBean.ACT_PROMPT_PIN:
				showChangePin = false;
				if (changePinReason == PIN_REASON_SUBMIT) {
					res = actionSubmit();
				}
				changePinReason = 0;
				break;
			case ACT_ATTACH:
				actionUploadAttachmentOk();
				break;
			case ACT_ACK_APPROVE:
				acknowledgeApprove = true;
				actionApprove();
				break;
		}
		return res;
	}

	@Override
	public String confirmCancel(int action) {
		String res = null;
		switch(action) {
			case ChangePinBean.ACT_PROMPT_PIN:
				showChangePin = false;
				changePinReason = 0;
				break;
			case ACT_CLONE:
				actionCloneDone();
				break;
			case ACT_DELETE_ITEM:
				res = actionDeleteCancel();
				break;
			case ACT_REJECT: // timecard was locked prior to prompt
				showReject = false;
				res = actionCancel();
				break;
			case ACT_VOID:
				actionVoidCancel();
				break;
			case ACT_PULL: // timecard was locked prior to prompt
			case ACT_RECALL: // timecard was locked prior to prompt
			case ACT_RECALL_TO_EMPL: // timecard was locked prior to prompt
				res = actionCancel();
//				getWeeklyTimecardDAO().unlock(weeklyTimecard, vUser.getId());
				break;
			case ACT_SUBMIT:
			case ACT_SUBMIT_APPROVE:
				res = actionSubmitCancel();
				break;
			case ACT_APPROVE:
				weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			default:
				res = super.confirmCancel(action);
				forceLazyInit();
				break;
		}
		return res;
	}

	/**
	 * ValueChangeListener method for all daily numeric fields.
	 * @param event contains old and new values
	 */
	public void listenDailyChange(ValueChangeEvent event) {
		if (! event.getPhaseId().equals(PhaseId.INVOKE_APPLICATION)) {
			// simpler to schedule event for later - after "setXxxx()" are called from framework
			event.setPhaseId(PhaseId.INVOKE_APPLICATION);
			event.queue();
			return;
		}
		//log.debug("id: " + event.getComponent().getId());
		boolean recalc = true;
		try {
			if (event.getOldValue() != null && event.getNewValue() != null) {
				try {
					double d1 = Double.valueOf(event.getOldValue().toString());
					double d2 = Double.valueOf(event.getNewValue().toString());
					if (d1 == d2) {
						recalc = false;
					}
				}
				catch (Exception e) { // ignore any conversion errors
					// log.error("",e);
				}
			}
			if (event.getNewValue() != null) {
				DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
				if (dailyTime != null) {
					if (event.getNewValue() instanceof DayType) {
						DayType dt = (DayType)event.getNewValue();
						if (dt.useHomeState()) { // Some Tours day types set default state; LS-1492
							dailyTime.setState(Constants.TOURS_HOME_STATE);
						}
						else if (Constants.TOURS_HOME_STATE.equals(dailyTime.getState())) {
							dailyTime.setState(null);
						}
						if (dt == DayType.HA && dailyTime.reportedWork()) {
							// user selected "HOA" - clear 'worked' fields. LS-2189
							dailyTime.setWorked(false);
							dailyTime.eraseInputHours();
						}

					}
					// LS-2161 Hybrid Timecard State/City Validations
					if (isHybridProduction()) {
						if (dailyTime.getDayType() != null) {
							setDefaultCityState(dailyTime);
						}
					}
				}
			}
			else {
				if(event.getOldValue() instanceof DayType) {
					// LS-2161 Hybrid Timecard State/City Validations
					if (isHybridProduction) {
						DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
						if (dailyTime != null) {
							setDefaultCityState(dailyTime);
						}
					}
				}
			}
			//log.debug("old: `" + event.getOldValue() + "`, new: `" + event.getNewValue() + "`; recalc: " + recalc);
			if (recalc) {
				DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
				if (dailyTime != null) {
					// Issue validation error msgs (if any) and calculate the hours of work for the changed day
					TimecardCheck.validateAndCalcWorkDay(dailyTime, true);
					// Calculate Total Hours and MPVs for week
					TimecardCalc.calculateWeeklyTotals(weeklyTimecard);
					//Calculate all the totals and get the status
					TimecardCalc.calculateOtherTotals(weeklyTimecard);
					checkEventValidity(event, "N/A");
					//LS-4589 enabled DailyTime checkboxes for DayType
					if (dailyTime.getDayType() == DayType.PS || dailyTime.getDayType() == DayType.WD) {
						if (weeklyTimecard.getStartForm().getModelRelease().getWeatherDay()) {
							dailyTime.setAllowWeather(true);
						}
						if (weeklyTimecard.getStartForm().getModelRelease().getIntimatesDay()) {
							dailyTime.setAllowIntimates(true);
						}
					}
					else {
						dailyTime.setAllowWeather(false);
						dailyTime.setAllowIntimates(false);
						dailyTime.setWeatherDay(false);
						dailyTime.setIntimatesDay(false);
					}
				}
			}
		}
		catch(Exception e) {
			log.error("id: " + event.getComponent().getId() + ", old: `" + event.getOldValue() + "`, new: `" + event.getNewValue() + "`; recalc: " + recalc);
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
	}

	public void listenNonDailyChange(ValueChangeEvent event) {
		if (! event.getPhaseId().equals(PhaseId.INVOKE_APPLICATION)) {
			// simpler to schedule event for later - after "setXxxx()" are called from framework
			event.setPhaseId(PhaseId.INVOKE_APPLICATION);
			event.queue();
			return;
		}
		try {
			//TimecardCheck.validateExpenseItems(weeklyTimecard);
			TimecardCheck.validateWeeklyFields(weeklyTimecard);
			//TimecardCheck.validatePayBreakdown(weeklyTimecard);
			//Calculate all the totals and get the status
			TimecardCalc.calculateOtherTotals(weeklyTimecard);
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
		// To save timecard events
		//checkEventValidity(event, description);
	}

	/**Method checks whether event will be stored or not.
	 * @param event
	 */
	protected void checkEventValidity(ValueChangeEvent event, String description) {
		String compId = "";
		try {
			compId = event.getComponent().getId();
			if (compId != null) {
				TimecardFieldType type = null;
				try {
					type = TimecardFieldType.valueOf(compId);
				}
				catch (Exception e) {
					log.error("comp id=" + compId + ", new value=" + event.getNewValue());
					EventUtils.logError(e);
					return; // do NOT notify user of error
				}
				if (event.getOldValue() == null) {
					if (event.getNewValue() != null) {
						if (! event.getNewValue().toString().trim().isEmpty()) {
							// value changed - create entry
							saveChangeEvent(event, type, description);
						}
					}
				}
				else {
					if(event.getOldValue().toString().isEmpty()) {
						if((event.getNewValue() != null) && (! event.getOldValue().equals(event.getNewValue()))) {
							// value changed - create entry
							saveChangeEvent(event, type, description);
						}
					}
					else {
						if (type.getClazz() == String.class) {
							if ((event.getNewValue() == null) || (! event.getOldValue().equals(event.getNewValue()))) {
								// value changed - create entry
								saveChangeEvent(event, type, description);
							}
						}
						else if (type.getClazz() == Boolean.class) {
							if ((event.getNewValue() == null) || ((Boolean)event.getOldValue()) != ((Boolean)event.getNewValue())) {
								// value changed - create entry
								saveChangeEvent(event, type, description);
							}
						}
						else if (type.getClazz() == Byte.class) {
							if ((event.getNewValue() == null) || ((Byte)event.getOldValue()) != ((Byte)event.getNewValue())) {
								// value changed - create entry
								saveChangeEvent(event, type, description);
							}
						}
						else if (type.getClazz() == BigDecimal.class) {
							if ((event.getNewValue() == null) || (((BigDecimal) event.getOldValue()).compareTo((BigDecimal)event.getNewValue()) != 0)) {
								// value changed - create entry
								saveChangeEvent(event, type, description);
							}
						}
					}
				}
			}
		}
		catch (Exception e) {
			log.error("comp id=`" + compId + "`, new value=" + event.getNewValue());
			EventUtils.logError(e);
			// do NOT notify user of error -- it shouldn't affect their data/results.
		}
	}

	/**
	 * ValueChangeListener method for all mileage fields.  NOTE: this
	 * method expects to be called during INVOKE_APPLICATION phase!
	 * @param event contains old and new values
	 */
	public void listenMileageChange(ValueChangeEvent event) {
		try {
			MileageLine mileageLine = (MileageLine)ServiceFinder.getManagedBean("mileage");
			if (mileageLine != null && weeklyTimecard.getMileage() != null) {
				if (mileageLine.getOdometerStart() != null && mileageLine.getOdometerEnd() != null) {
					mileageLine.setMiles(null);
				}
				// Validate mileage fields & generate any error messages
				TimecardCheck.validateMileageLine(mileageLine);
				weeklyTimecard.getMileage().setMiles(null); // force re-totaling
				TimecardUtils.updateMileageExpense(weeklyTimecard);
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
	}

	/**
	 * ValueChangeListener for the Box amount on the box rental form.
	 * @param event contains old and new values
	 */
	public void listenBoxRentalAmount(ValueChangeEvent event) {
		try {
			if (weeklyTimecard != null) { // Fix NPE, LS-1064 6/1/18
				if (event.getNewValue() != null && event.getOldValue() != null &&
						event.getNewValue() instanceof BigDecimal && event.getOldValue() instanceof BigDecimal) {
					BigDecimal newv = (BigDecimal)event.getNewValue();
					BigDecimal oldv = (BigDecimal)event.getOldValue();
					if (newv.compareTo(oldv) == 0) {
						// Don't process this if values are the same; this prevents us re-updating the
						// expense table (incorrectly, perhaps) after the user has clicked the
						// "copy to timecard" button.
						return;
					}
				}
				if (weeklyTimecard.getBoxRental() != null) {
					if (TimecardCheck.validateBoxRental(weeklyTimecard.getBoxRental().getAmount())) {
						//2.9.5416			TimecardUtils.updateBoxRentalExpense(weeklyTimecard, false, false);
					}
				}
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
	}

	/**
	 * ValueChangeListener method for the category drop-down in the
	 * Expense/Reimbursement table. This is called in the INVOKE_APPLICATION
	 * phase.
	 *
	 * @param event contains old and new values
	 */
	public void listenExpenseCategory(ValueChangeEvent event) {
		try {
			PayCategory pc = (PayCategory)event.getNewValue();
			int n = weeklyTimecard.getExpenseLines().size() - 1;
			if (pc != null && n >= 0) { // n may be -1 in odd case. rev 2.2.4919
				PayExpense exp = new PayExpense(weeklyTimecard, (byte)n);
				exp.setCategory(pc.getLabel());
				weeklyTimecard.getExpenseLines().add(n, exp);
				TimecardUtils.renumberExpenseLines(weeklyTimecard);  // just to be safe!
				setExpCategory(null);

				StartForm sf = weeklyTimecard.getStartForm();
				sf = StartFormDAO.getInstance().refresh(sf);
				AccountCodes ac = sf.getByPayCategory(pc);
				if (ac != null) {
					exp.setAccountCodes(ac);
				}
				else if (pc.getIsLabor()) {
					// for labor items, copy all account codes from the timecard. 2.9.5599
					exp.setAccountCodes(weeklyTimecard.getAccount());
				}
				else {
					// For non-labor items,
					// only set Loc and Prd/Epi (Major) if using timecard's fields. 2.9.5599
					exp.setAccountLoc(weeklyTimecard.getAccountLoc());
					exp.setAccountMajor(weeklyTimecard.getAccountMajor());
				}
				if (pc == PayCategory.MILEAGE_NONTAX || pc == PayCategory.MILEAGE_TAX) {
					PayrollPreference pref;
					if (sf.getProject() == null) { // TV/Feature
						Production prod = TimecardUtils.findProduction(weeklyTimecard);
						pref = prod.getPayrollPref();
					}
					else { // Commercial
						pref = sf.getProject().getPayrollPref();
					}
					exp.setRate(pref.getMileageRate());
				}
			}
			if (weeklyTimecard != null) {
				log.debug("ADD_LINE event  for weeklyTimecard");
				storeEventForTimecards(TimedEventType.CHANGE, TimecardFieldType.ADD_LINE, n+1, (pc == null ? "" : pc.getLabel()) );
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addFacesMessage("Generic.SystemError", FacesMessage.SEVERITY_ERROR);
		}
	}

	/**
	 * ValueChangeListener for the "mark for approval" checkbox.
	 * @param event The event created by the framework.
	 */
	public void listenMark(ValueChangeEvent event) {
		if (event != null) {
			try {
				if (weeklyTimecard != null && ! getEditMode()) {
					boolean b = (Boolean)event.getNewValue();
					weeklyTimecard.setMarkedForApproval(b);
					weeklyTimecard = getWeeklyTimecardDAO().merge(weeklyTimecard);
				}
			}
			catch (Exception e) {
				EventUtils.logError(e);
				MsgUtils.addGenericErrorMessage();
			}
		}
	}

	/**
	 * ValueChangeListener method for the Work State drop-down list. This is
	 * called in the INVOKE_APPLICATION phase. This is on both the Full
	 * and Basic timecard pages.
	 *
	 * @param event contains old and new values
	 */
	public void listenWorkStateChange(ValueChangeEvent event) {
		try {
			String state = (String)event.getNewValue();
			// Is it ok to propagate State if non-hybrid? (What LS has 'always' done.)
			if (state != null && weeklyTimecard != null && getViewProduction() != null &&
					(! getViewProduction().getPayrollPref().getIncludeTouring())) {
				for (DailyTime dt : weeklyTimecard.getDailyTimes()) {
					dt.setState(state);
					dt.setCities(cityDL(dt));//LS-4802 set cities list
				}
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addFacesMessage("Generic.SystemError", FacesMessage.SEVERITY_ERROR);
		}
	}

	/**
	 * ValueChangeListener method for the Work City drop-down list. This is
	 * called in the INVOKE_APPLICATION phase. This is on both the Full
	 * and Basic timecard pages. LS-4589
	 *
	 * @param event contains old and new values
	 */
	public void listenWorkCityChange(ValueChangeEvent event) {
		try {
			String city = (String)event.getNewValue();
            // Is it ok to propagate City if non-hybrid? (What LS has 'always' done.)
			if (city != null && weeklyTimecard != null && getViewProduction() != null &&
					(! getViewProduction().getPayrollPref().getIncludeTouring())) {
				for (DailyTime dt : weeklyTimecard.getDailyTimes()) {
					dt.setCity(city);
				}
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addFacesMessage("Generic.SystemError", FacesMessage.SEVERITY_ERROR);
		}
	}

	/**
	 * ValueChangeListener method for the Work Country drop-down list. This is
	 * called in the INVOKE_APPLICATION phase. This is on both the Full
	 * and Basic timecard pages.
	 *
	 * @param event contains old and new values
	 */
	public void listenWorkCountryChange(ValueChangeEvent event) {
		try {
			String country = (String)event.getNewValue();
			if (country != null && weeklyTimecard != null) {
				getCountryStateCodeDL();
			}
		}
		catch(Exception e) {
			EventUtils.logError(e);
			MsgUtils.addFacesMessage("Generic.SystemError", FacesMessage.SEVERITY_ERROR);
		}
	}

	/**
	 * Creates a list of states for the selected work country.
	 * Used in JSP.
	 *
	 * @return list of states for the current timecard's Work Country
	 */
	public List<SelectItem> getCountryStateCodeDL() {
		String country= Constants.DEFAULT_COUNTRY_CODE;
		if (getWeeklyTimecard().getWorkCountry() != null) {
			country = getWeeklyTimecard().getWorkCountry();
		}
		List<SelectItem> stateList = ApplicationScopeBean.getInstance().getStateCodeDL(country);
		//LS-2471 removed FO from stateList if the country US when production is Hybrid
		if (isHybridProduction() && country.equals(Constants.DEFAULT_COUNTRY_CODE)) {
			stateList = new ArrayList<>(stateList);
			Iterator<SelectItem> iter = stateList.iterator();
			for (; iter.hasNext();) {
				SelectItem item = iter.next();
				if (item.getLabel().equals(Constants.FOREIGN_FO_STATE)) {
					// remove "FO" for tours-hybrid. LS-2471
					iter.remove();
				}
			}
		}
		return stateList;
	}

	/**
	 * LS-2562
	 * Determines whether the loan-out section should be shown.
	 *
	 * @param event
	 */
	public void listenPaidAsChange(ValueChangeEvent event) {
		PaidAsType paidAs = (PaidAsType)event.getNewValue();
		weeklyTimecard.getStartForm().setPaidAs(paidAs);
	}

	/**
	 * Insert blank PayBreakdown or Expense table line item.
	 * @param wtc The timecard to be updated.
	 */
	protected void insertExtraPbLine(WeeklyTimecard wtc) {
		int n = wtc.getPayLines().size();
		if (getEditHtg() && (! isTeamPayroll()) &&
				(n == 0 || wtc.getPayLines().get(n-1).getCategory() != null)) {
			PayBreakdown pb = new PayBreakdown(wtc, (byte)(n+1));
			wtc.getPayLines().add(pb);
		}
		n = wtc.getExpenseLines().size();
		if (getEditExpense() &&
				(n == 0 || wtc.getExpenseLines().get(n-1).getCategory() != null)) {
			PayExpense exp = new PayExpense(wtc, (byte)(n+1));
			wtc.getExpenseLines().add(exp);
		}
	}

	/**
	 * Removes the last line item in either the Pay Breakdown table or
	 * the Expense table.
	 * @param wtc The timecard to be updated.
	 */
	protected void removeExtraPbLine(WeeklyTimecard wtc) {
		if (editHtg) {
			int n = wtc.getPayLines().size();
			if (n > 0 && wtc.getPayLines().get(n-1).getCategory() == null) {
				wtc.getPayLines().remove(n-1);
			}
		}
		if (getEditExpense()) {
			int n = wtc.getExpenseLines().size();
			if (n > 0 && wtc.getExpenseLines().get(n-1).getCategory() == null) {
				wtc.getExpenseLines().remove(n-1);
			}
		}
	}

	/**
	 * Attempt to lock the current timecard. If the lock fails, put up the
	 * prompt dialog.
	 *
	 * @param msgType The 'additional' part of the message id for the prompt.
	 *            This should be an empty string ("") if the default 'lock
	 *            failed' message is desired.  The message id used to look
	 *            up the prompt is <"Timecard.CardLocked." + msgType + "Text">.
	 * @return True iff the current WeeklyTimecard has been locked.
	 */
	protected boolean lockAndPrompt(String msgType) {
		if (! getWeeklyTimecardDAO().lock(weeklyTimecard, getvUser())) {
			PopupBean.getInstance().show(null, 0,
					"Timecard.CardLocked.Title",
					"Timecard.CardLocked." + msgType + "Text",
					"Confirm.OK", null); // no cancel button
			log.debug("edit/recall/etc prevented: locked by user #" + weeklyTimecard.getLockedBy());
			editMode = false;
			return false;
		}
		return true;
	}

	/**
	 * Called when our WeeklyTimecard's "status" has changed, e.g., it's been approved
	 * or recalled, etc., and we need to recalculate (or force new lazy initialization)
	 * of status-related data.
	 */
	protected void statusChanged(WeeklyTimecard wtc) {
		if (wtc != null) {
			calculateApproverFlags(wtc);
			updateItemInList(wtc);
			forceLazyInit();
		}
		approverName = null;
	}

	/**
	 * Determine the current user authority to perform various operations on the
	 * current timecard. Their authority is based on several factors, including
	 * whether they are in the approval chain for the supplied timecard, if they
	 * are the owner of the timecard, and whether or not they are the next
	 * approver. The method sets several boolean fields including
	 * {@link #approvalAuth}, {@link #mayApprove}, {@link #editAuth} ,
	 * {@link #recallAuth}, {@link #pullAuth}, and {@link #cloneAuth}
	 * accordingly. These fields are used both in the Java code, and in the JSP
	 * pages to control the display of data and controls.
	 *
	 * @param wtc The timecard in question
	 */
	protected void calculateApproverFlags(Approvable wtc) {
		submitMsg = "";
		recallAuth = false;
		pullAuth = false;
		mayApprove = false;
		approvalAuth = false;
		editAuth = false;
		cloneAuth = false;

		// Build 'submitted' msg & determine if an approval occurred after the last Submit
		boolean approvedAfterSubmit = createSubmittedMsg(wtc);

		if (wtc.getStatus() == ApprovalStatus.VOID) {
			// Can't do anything to a VOID timecard!
			return;
		}

		Production prod = getViewProduction();
		if (prod.getStatus().getAllowsWrite()) {
			String docUserAcct;
			if (wtc instanceof WeeklyTimecard) {
				docUserAcct = ((WeeklyTimecard)wtc).getUserAccount();
			}
			else {
				docUserAcct = ((ContactDocument)wtc).getContact().getUser().getAccountNumber();
			}

			// true iff the timecard being viewed belongs to the current user:
			boolean userOwnsTimecard = docUserAcct.equals(getvUser().getAccountNumber());

			if (notInProduction) { // on My Timecard page(s) - user is not "in" a production
				if (userOwnsTimecard) {
					if (wtc.getSubmitable()) {
						// Open, or rejected to employee.  Only employee can edit since we're outside of any production.
						editAuth = true;
					}
					else {
						recallAuth = (! approvedAfterSubmit);
					}
				}
				// no approval activity is allowed from My Timecards
				return;
			}
			calculateApprovalAuth(wtc, prod, true); // sets mayApprove, approvalAuth, and cloneAuth

			// Does the current user have Edit capability, for either raw or HTG data, in this timecard?
			if (wtc.getSubmitable()) {
				// Open, or rejected to employee.  Employee, any approver, or time-keeper can edit.
				editAuth = userOwnsTimecard;
				editAuth |= cloneAuth; // approvalAuth or timeKeeper implies editAuth
			}
			else {
				// not 'open/re-opened' - might be next approver
				editAuth = mayApprove | authBean.getPseudoApprover();
				// may have immediate recall authority if owner of timecard
				recallAuth = userOwnsTimecard && (! approvedAfterSubmit);
			}

			if ((! editAuth) && approvalAuth) { // check for possible Pull or Recall authority
				if (wtc.getApproverId() != null ) {
					// rev 2.9.5447 - dropped edit-HTG required for pullAuth
					// Passed easy tests -- gets pull authority if later in approval chain
					Project tcProj = TimecardUtils.findProject(viewProduction, wtc);
					pullAuth = TimecardUtils.followsCurrentApprover(wtc, tcProj, getvContact(), null);
				}
				if ((! pullAuth) && (! recallAuth) &&
						(! wtc.getSubmitable()) &&
						wtc.getStatus() != ApprovalStatus.LOCKED) {
					// Recall allowed even if TC has final approval.
					// rev 2.2.4772 - don't require Edit-HTG to do Recall
					// Passed the 'easy' tests -- maybe will get recall authority.
					calculateRecallAuth(wtc);
				}
			}
		}
	}

	/**
	 * Create a "submitted by" message to be displayed for a timecard.
	 *
	 * @param wtc The timecard of interest.
	 * @return True iff the given timecard has been approved by anyone since it
	 *         was last submitted.
	 */
	private boolean createSubmittedMsg(Approvable wtc) {
		// Find last submit event for Submit msg on Full Timecard page;
		// also determine if any approval has occurred after the last Submit
		boolean approvedAfterSubmit = false;
		for (@SuppressWarnings("rawtypes")
				SignedEvent evt : wtc.getEvents()) {
			if (evt.getType() == TimedEventType.SUBMIT) {
				submitMsg = "Submitted by " + evt.getName() + " on " + evt.getDisplayTime();
				approvedAfterSubmit = false;
			}
			else if (evt.getType() == TimedEventType.APPROVE) {
				approvedAfterSubmit = true;
			}
		}
		return approvedAfterSubmit;
	}

	/**
	 * Calculate 3 timecard-related flags: {@link #mayApprove},
	 * {@link #approvalAuth}, and {@link #cloneAuth}. The 'cloneAuth' value, in
	 * particular, is needed for Mobile timecards, whereas the additional flags
	 * calculated by calculateApproverFlags are not needed for mobile.
	 *
	 * @param wtc The timecard in question
	 * @param prod The Production the timecard is for.
	 * @param writeOk True iff the Production allows write access. This will be
	 *            false, for example, for an Archived production.
	 */
	private void calculateApprovalAuth(Approvable wtc, Production prod, boolean writeOk) {
		mayApprove = false;
		approvalAuth = writeOk && authBean.getPseudoApprover(); // normally false unless LS Admin enables it
		cloneAuth = approvalAuth;

		if (writeOk) {
			// Can the current user Approve/Reject this timecard?
			mayApprove = ApproverUtils.isNextApprover(wtc, getvContact().getId());

			// Is the current user somewhere in the approval chain for this timecard?
			approvalAuth |= mayApprove;
			Project tcProj = null;
			if (! approvalAuth) {
				tcProj = TimecardUtils.findProject(viewProduction, wtc);
				if (tcProj != null) {
					tcProj = ProjectDAO.getInstance().refresh(tcProj);
				}
				Contact contact = SessionUtils.getCurrentContact();
				if (contact != null) {
					approvalAuth = ApproverUtils.isApprover(contact, tcProj, wtc.getDepartment());
				}
			}

			cloneAuth |= approvalAuth;
			if (! cloneAuth) {
				if (tcProj == null && viewProduction.getType().isAicp()) {
					tcProj = TimecardUtils.findProject(viewProduction, wtc);
					if (tcProj != null) {
						tcProj = ProjectDAO.getInstance().refresh(tcProj);
					}
				}
				cloneAuth = ApproverUtils.isTimeKeeper(getvContact(), tcProj, wtc.getDepartment());
			}
		}
	}

	/**
	 * Determine if the current user should get "Recall" authority. This will be
	 * true if the user has approved the timecard at least once, and the
	 * timecard has not been recalled back "in front of them" since their last
	 * approval.
	 * <p>
	 * Sets {@link #recallAuth} before returning.
	 *
	 * @param wtc The timecard of interest.
	 */
	private void calculateRecallAuth(Approvable wtc) {
		// Will qualify if the user approved the timecard at least once,
		// unless the timecard has been recalled "in front of" them.
		String currAcct = getvUser().getAccountNumber();
		int rejIx = -1;
		int apprIx = -1;
		// Find last approval (by this user) & last reject/recall (by anyone)
		for (int i = 0; i < wtc.getEvents().size(); i++) {
			@SuppressWarnings("rawtypes")
			SignedEvent evt = wtc.getEvents().get(i);
			if (evt.getType() == TimedEventType.REJECT ||
					evt.getType() == TimedEventType.RECALL) {
				rejIx = i; // track last reject/recall
			}
			else if (evt.getType() == TimedEventType.APPROVE
					&& evt.getUserAccount().equals(currAcct)) {
				apprIx = i; // track current user's last approval
			}
		}
		if (apprIx >= 0) { // at least one approval by this user
			if (apprIx > rejIx) { // no rejects, or approved after the last reject
				recallAuth = true;
			}
			else {
				// have to see if this approver is earlier in the chain than
				// the current approver.
				Project tcProj = TimecardUtils.findProject(viewProduction, wtc);
				recallAuth = TimecardUtils.precedesCurrentApprover(wtc, tcProj, getvContact(), null);
			}
		}
	}

	/**
	 * Calculate authorization flags for mobile timecard pages. This sets four
	 * timecard-related flags: {@link #mayApprove}, {@link #approvalAuth},
	 * {@link #recallAuth} and {@link #cloneAuth}.
	 *
	 * @param wtc The timecard in question
	 */
	protected void calculateMobileAuth(WeeklyTimecard wtc) {

		cloneAuth = false; // assume no authorization
		mayApprove = false;
		approvalAuth = false;
		recallAuth = false;

		if (wtc.getStatus() == ApprovalStatus.VOID) {
			// Can't do anything to a VOID timecard!
			return;
		}

		Production prod = SessionUtils.getNonSystemProduction();
		if (prod == null) { // happens for My Timecard page(s) - user is not in a production
			return;
		}
		boolean writeOk = prod.getStatus().getAllowsWrite();
		if (writeOk) {
			calculateApprovalAuth(wtc, prod, true);
			boolean userOwnsTimecard = wtc.getUserAccount().equals(getvUser().getAccountNumber());
			if (userOwnsTimecard && (! wtc.getSubmitable())) {
				// Determine if an approval occurred after the last Submit
				boolean approvedAfterSubmit = createSubmittedMsg(wtc);
				recallAuth = ! approvedAfterSubmit;
			}
		}
	}

	/**
	 * Determine the rounding type for the current timecard, and put it in the
	 * Session variable.
	 */
	protected void calculateRoundingType() {
		// Set rounding type...
		HourRoundingType round = HourRoundingType.TENTH;
		Boolean roundDecimal = true; // ALL inputs will be rounded. rev 2.9.5700
		if (viewProduction != null) {
			Project proj = ProjectDAO.getInstance().refresh(weeklyTimecard.getStartForm().getProject());
			if (weeklyTimecard.isNonUnion()) {
				roundDecimal = true;
				if (proj != null) { // Commercial
					round = proj.getPayrollPref().getHourRoundingType();
				}
				else { // TV/Feature
					round = viewProduction.getPayrollPref().getHourRoundingType();
				}
			}
			else { // Union timecard
				if (proj != null) { // Commercial
					round = HourRoundingType.FOURTH;
				}
				else { // TV/Feature
					round = HourRoundingType.TENTH;
				}
			}
		}
		SessionUtils.put(Constants.ATTR_TIME_ROUNDING_TYPE, round);
		SessionUtils.put(Constants.ATTR_ROUND_DECIMAL_TIME, roundDecimal);

	}

	/**
	 * @return True iff there is a timecard that has a week-ending date one week
	 *         prior to the currently displayed timecard and that has non-zero
	 *         total hours.  Used to set the {@link #showCopyPrior} field.
	 */
	private Boolean calculateShowCopyPrior() {
		Boolean ret = null;
		if (weeklyTimecard != null) {
			ret = getWeeklyTimecardDAO().existsPriorNonZeroTimecard(weeklyTimecard);
		}
		return ret;
	}

	private boolean calculateShowLegend(DayType dayType) {
		boolean ret = false;
		if (weeklyTimecard != null) {
			for (DailyTime dt : weeklyTimecard.getDailyTimes()) {
				if (dt.getDayType() != null && dt.getDayType() == dayType) {
					ret = true;
					break;
				}
			}
		}
		return ret;
	}

	/**
	 * Create the Expense category drop-down.
	 * @return The List of SelectItem to be presented. Customized based on if the
	 * current timecard is a Model Release timecard or not.
	 */
	private List<SelectItem> createExpCategoryDL() {
		List<SelectItem> list = new ArrayList<>();
		boolean forModelRelease = getUseModelRelease(); // LS-4651
		for (PayCategory p : PayCategory.values()) {
			if (((!forModelRelease) && p.getIsExpense()) ||
					(forModelRelease && p.getForModelRelease())) {
				list.add(new SelectItem(p, p.toString()));
			}
		}
		list.add(0, new SelectItem(null, "Add Line Item"));
		return list;
	}

	/**
	 * Create the employee version of the Expense category drop-down.
	 * This one omits the Mileage and Box Rental items.
	 */
	private List<SelectItem> createEmplExpCategoryDL() {
		List<SelectItem> list = new ArrayList<>();
		boolean forModelRelease = getUseModelRelease(); // LS-4651
		for (PayCategory p : PayCategory.values()) {
			if (((!forModelRelease) && p.getIsEmplExpense()) ||
					(forModelRelease && p.getForModelRelease())) {
				list.add(new SelectItem(p, p.toString()));
			}
		}
		list.add(0, new SelectItem(null, "Add Line Item"));
		return list;
	}

	/**
	 * Creates the List of all the timecards for one person (based on the value
	 * of {@link TimecardBase#tcUser}) within the current Production which
	 * should be visible to the current (logged-in) user. For example, a
	 * department approver can only see those timecards related to the
	 * Department`s for which they are an approver. If the current Production is
	 * null, an empty List is created.
	 *
	 * @return A non-null List of WeeklyTimecard`s.
	 */
	protected List<WeeklyTimecard> createWeeklyTimecardListUser() {
		Production prod;
		Project project;
		String currentUserAcc;
		if (getNotInProduction()) { // true iff My Timecards page
			prod = getViewProduction();
			project = null;
			currentUserAcc = getvUser().getAccountNumber();
		}
		else {
			prod = SessionUtils.getNonSystemProduction();
			currentUserAcc = tcUser.getAccountNumber();
			project = getViewProject();
		}

		List<WeeklyTimecard> tcList;
		if (prod == null) {
			tcList = new ArrayList<>();
		}
		else {
			tcList = getWeeklyTimecardDAO().findByUserAccount(prod, project, currentUserAcc, null);
		}
		return tcList;
	}

//	/**
//	 * Determine if the specified StartForm, within the specified Production,
//	 * includes any week-ending dates for which there is no WeeklyTimecard. If
//	 * so, return true, else return false. This is used to determine which
//	 * StartForm`s are listed in the drop-down list within the "Create Timecard"
//	 * dialog box.
//	 *
//	 * @param sd The StartForm of interest.
//	 * @param adjustedTimecard The setting of the "adjusted timecard" checkbox
//	 *            -- true if the check-box is checked, meaning that we will
//	 *            include dates for which a timecard already exists.
//	 * @return True iff the selection of this StartForm on the "Create Timecard"
//	 *         pop-up would result in the listing of at least one week-ending
//	 *         date for which a timecard could be created.
//	 */
//
// NO LONGER USED as of r3.2.6.9108; note that this code is incorrect, as it does
// not take the payrollPreference.maxWeeksInAdvance into account.
//
//	protected boolean existsWeekEndDate(StartForm sd, boolean adjustedTimecard) {
//		boolean exists = false;
//		Calendar cal = Calendar.getInstance();
//		if (sd.getEmployment() != null && sd.getEmployment().getEndDate() != null) {
//			// Employment endDate takes precedence over StartForm
//			cal.setTime(sd.getEmployment().getEndDate());
//		}
//		else if (sd.getEarliestEndDate() != null) {
//			cal.setTime(sd.getEarliestEndDate());
//		}
//		else {
//			cal.add(Calendar.DAY_OF_MONTH, 14); // just need to be past +10 days
//		}
//		cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
//		Date lastDate = cal.getTime(); // Saturday after the work-end date
//
//		cal = Calendar.getInstance();
//		CalendarUtils.setStartOfDay(cal);
//		int dayOfWk = cal.get(Calendar.DAY_OF_WEEK);
//		cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
//		if (dayOfWk > Calendar.WEDNESDAY) { // next week-end is < 10 days away
//			cal.add(Calendar.DAY_OF_MONTH, 7); // so this is latest date
//		}
//		if (lastDate.after(cal.getTime())) {
//			lastDate = cal.getTime();
//		}
//
//		cal.setTime(sd.getWorkStartOrHireDate());
//		if (sd.getEffectiveStartDate() != null &&
//				sd.getEffectiveStartDate().after(sd.getWorkStartOrHireDate())) {
//			cal.setTime(sd.getEffectiveStartDate());
//		}
//		// Set the calendar to Saturday of the user's first week
//		cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
//		Date date = cal.getTime();
//		while(! date.after(lastDate)) {
//			if (adjustedTimecard ||
//					! getWeeklyTimecardDAO().existsWeekEndDateAccountOccupation(getViewProduction(), sd.getProject(),
//							date, tcUser.getAccountNumber(), sd.getJobClass())) {
//				exists = true;
//				break;
//			}
//			cal.add(Calendar.DAY_OF_MONTH, 7);
//			date = cal.getTime();
//		}
//		return exists;
//	}

	/**
	 * Create any missing timecards for the given User, in the given Production,
	 * for the week ending on the given Date.
	 *
	 * @param user The User to create timecards for.
	 * @param prod The Production the timecards are for.
	 * @param date The week-ending date of the timecards to be created.
	 * @return A Collection (possibly null) of WeeklyTimecard`s that were
	 *         created.
	 */
//	public static Collection<WeeklyTimecard> createTimecards(User user, Production prod, Date date) {
//		Set<WeeklyTimecard> cards = new HashSet<WeeklyTimecard>();
//		Contact contact = ContactDAO.getInstance().findByUserProduction(user, prod);
//		List<StartForm> docs = StartFormDAO.getInstance().findByProperty(StartFormDAO.CONTACT, contact);
//
//		for (StartForm doc : docs) {
//			if (! doc.getWorkStartDate().after(date)) { // starts before or on given week-end date...
//				Date priorWeek = TimecardUtils.getPriorWeekEndDate(date);
//				if (doc.getWorkEndDate().after(priorWeek)) {	// ...and ends this week or later
//					// ...so the requested week-end date is within this StartForm's date range
//					if (! WeeklyTimecardDAO.getInstance().existsUserWeekEndDate(prod, user, date, doc.getJobClass())) {
//						// We do not already have a matching timecard, so we should be able to create one...
//						WeeklyTimecard wtc = createTimecard(user, prod, date, doc);
//						if (wtc != null) {
//							cards.add(wtc);
//						}
//					}
//				}
//			}
//		}
//		return cards;
//	}

	/**
	 * @see com.lightspeedeps.web.view.ListView#isDefaultAscending(String)
	 */
	@Override
	public boolean isDefaultAscending(String sortColumn) {
		return false; // make columns default to descending sort
	}

	/**
	 * @see com.lightspeedeps.web.view.ListView#getComparator()
	 */
	@SuppressWarnings("rawtypes")
	@Override
	protected Comparator getComparator() {
		log.debug("col=" + getSortColumnName());
		Comparator<WeeklyTimecard> comparator = new Comparator<WeeklyTimecard>() {
			@Override
			public int compare(WeeklyTimecard one, WeeklyTimecard two) {
				return one.compareTo(two, getSortColumnName(), isAscending());
			}
		};
		return comparator;
	}

	/**
	 * @see com.lightspeedeps.web.view.ListView#setSelected(Object, boolean)
	 */
	@Override
	protected void setSelected(Object item, boolean b) {
		try {
			log.debug("");
			((WeeklyTimecard)item).setSelected(b);
		}
		catch (Exception e) {
			EventUtils.logError(e);
		}
	}

	/**
	 * Called when selected (viewed) {@link #weeklyTimecard} has changed.
	 */
	protected void timecardChanged() {
		hasTouringRates = false;
		useModelRelease = null; // force refresh. LS-4664
		modelRelease = null; // force refresh. LS-4664
		if (weeklyTimecard != null) {
			if (weeklyTimecard.getStartForm() != null) {
				hasTouringRates = weeklyTimecard.getStartForm().getHasTourRates(); // LS-1347
			}
			if (weeklyTimecard.isNonUnion() && weeklyTimecard.getAllowWorked() && isTeamPayroll()) {
				// Create DayType list for exempt, non-union - needs HOA. LS-2189
				dayTypeExemptList = null;
				dayTypeExemptList = new ArrayList<>(getDayTypeDL());
				// add HOA to appropriate list (tours vs hybrid vs crew)
				dayTypeExemptList.add(new SelectItem(DayType.HA, DayType.HA.toString()));
			}
			else {
				dayTypeExemptList = new ArrayList<>();
			}
		}

		/*if user switches timecard while viewing attachments tab
		and the new timecard doesn't have any attachments.*/
		if (getSelectedTab() == TAB_TC_ATTACHMENTS) {
			if (weeklyTimecard.getAttachments() == null || weeklyTimecard.getAttachments().isEmpty()) {
				setSelectedTab(TAB_MAIN);
				log.debug("");
			}
			else if (! getAttachmentBean().getWeeklyTimecard().equals(weeklyTimecard)) {
				log.debug("");
				SessionUtils.put(Constants.ATTR_TIMECARD_ATTACHMENT_ID, null);
				getAttachmentBean().viewAttachments(null, null, weeklyTimecard);
			}
		}
		if (getAttachmentBean().getWeeklyTimecard() == null ||
				(! getAttachmentBean().getWeeklyTimecard().equals(weeklyTimecard))) {
			SessionUtils.put(Constants.ATTR_TIMECARD_ATTACHMENT_ID, null);
			getAttachmentBean().setWeeklyTimecard(weeklyTimecard);
		}
	}

	/**
	 * @see com.lightspeedeps.web.view.View#setupTabs()
	 */
	@Override
	protected void setupTabs() {
		super.setupTabs();
		// fix lazyInitializationException switching to Box and Mileage mini-tabs:
		viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
	}

	/**
	 * This method is called by our subclasses (which are called by the JSF
	 * framework) when this bean is about to go 'out of scope', e.g., when the
	 * user is leaving the page. Note that in JSF 2.1, this method is not called
	 * for session expiration, so we handle that case via the Disposable
	 * interface.
	 */
	public void preDestroy() {
		log.debug("");
		if (disposer != null) {
			disposer.unregister(this);
		}
		dispose();
	}

	/**
	 * This method is called when this bean is about to go 'out of scope', e.g.,
	 * when the user is leaving the page or their session expires. We use it to
	 * unlock the WeeklyTimecard to make it available again for editing.
	 */
	@Override
	public void dispose() {
		log.debug("");
		try {
			if (weeklyTimecard != null && getvUser() != null) {
				weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard); // prevent "non-unique object" failure in logout case
				if (weeklyTimecard != null && weeklyTimecard.getLockedBy() != null
						 && getvUser().getId().equals(weeklyTimecard.getLockedBy())) {
					log.debug("dispose calling unlock");
					getWeeklyTimecardDAO().unlock(weeklyTimecard, getvUser().getId());
				}
			}
			timecardEventList = null;
			if (weeklyTimecard != null) {
				getWeeklyTimecardDAO().evict(weeklyTimecard);
				weeklyTimecard = null;
			}
		}
		catch (Exception e) {
			log.error("Exception: ", e);
		}
	}

	/**
	 * Determine whether or not the Box rental form's amount is the same as the
	 * Start Form.
	 *
	 * @return True if the Box Rental form does not exist, or if it does and its
	 *         amount is the same as the Start Form's box rental amount.
	 */
	public boolean getBoxMatchesStart() {
		boolean match = true;
		if (weeklyTimecard != null &&
				weeklyTimecard.getBoxRental() != null) {
			if (weeklyTimecard.getBoxRental().getMatchesStart() == null) {
				match = TimecardUtils.updateBoxRentalMatch(weeklyTimecard);
			}
			else {
				match = weeklyTimecard.getBoxRental().getMatchesStart();
			}
		}
		return match;
	}

	/**
	 * Determine the appropriate additional text for the "Box Rental" mini-tab
	 * label, based on whether that form's amount matches the Start Form amount.
	 *
	 * @return A null string if the amounts match (or the Box Rental form is
	 *         non-existent), otherwise a string like "(*123.00*)" where the
	 *         amount in the string is the Box Rental form's amount.
	 */
	public String getBoxTabText() {
		String tab = null;
		if (! getBoxMatchesStart()) {
			BigDecimal amount = weeklyTimecard.getBoxRental().getAmount();
			if (amount == null || amount.signum() == 0) {
				tab = "0";
			}
			else {
				tab = amount.toPlainString();
			}
			tab = "(*" + tab + "*)";
		}
		return tab;
	}

	/**
	 * List of PaidAsTypes that determine whether the employee will
	 * be paid as an individual or loan-out
	 * LS-2562
	 *
	 * @return list of PaidAsTypes
	 */
	public List<SelectItem> getPaidAsDL() {
		return EnumList.getPaidAsList();
	}

	/**
	 * @return the current PayrollPreference instance; this will be for the
	 *         current Production for TV/Feature, or the current Project for
	 *         Commercials.
	 */
	public PayrollPreference getPayrollPref() {
		PayrollPreference pref = null;
		if (viewProduction != null) {
			if (viewProduction.getType().isAicp()) {
				if (weeklyTimecard != null) {
					StartForm sf = weeklyTimecard.getStartForm();
					sf = StartFormDAO.getInstance().refresh(sf);
					pref = sf.getProject().getPayrollPref();
				}
				else if (commProject != null) { // should be non-null!
					pref = commProject.getPayrollPref();
				}
			}
			else {
				pref = viewProduction.getPayrollPref();
			}
		}
		if (pref != null) {
			// Fix for the LIE error #490158 2/17/2017; rev 7487
			pref = PayrollPreferenceDAO.getInstance().refresh(pref);
		}
		return pref;
	}

	/** Method used to save the timecard change event for each event received by the listener.
	 * Method will be invoked every time when the user changes any number field for any number of times.
	 * @param event
	 * @param type2
	 */
	private void saveChangeEvent(ValueChangeEvent event, TimecardFieldType type, String description) {
		Integer row = -2;
		UIData daily = (UIData)event.getComponent().findComponent("cday"); // id of data table in fulltcConsolidated
		if (daily != null) {
			row = daily.getRowIndex();
		}
		else {
			UIData expense = (UIData)event.getComponent().findComponent("expenseTable"); // id of data table in tcExpense
			if (expense != null) {
				row = expense.getRowIndex();
				//if (row != null) {
					//log.debug("................ ..field Row no. =" + row);
				//}
			}
			else {
				UIData pay = (UIData)event.getComponent().findComponent("cpaybrk"); // id of data table in fulltcPayBreakdown
				if (pay != null) {
					row = pay.getRowIndex();
					//if (row != null) {
						//log.debug("...................field Row no. =" + row);
					//}
				}
			}
		}

		if (type != null && weeklyTimecard != null) {
			TimecardChangeEvent tcChange = new TimecardChangeEvent(getvUser(), TimedEventType.CHANGE, weeklyTimecard.getId(),
					type, row + 1, description, event.getOldValue(), event.getNewValue());
			TimecardChangeEventDAO.getInstance().save(tcChange);
			setTimecardEventList(null);
		}
	}

	/**
	 * Method used to save the timecard's TimedEventType events. Method will be
	 * invoked every time when the user performs save, edit or cancel on
	 * timecard.
	 *
	 * @param type The event type, e.g., SAVE or CHANGE.
	 * @param fieldType The field being changed, or null if N/A.
	 * @param lineNumber Line number (origin 1) within the table being changed,
	 *            or -1 if unknown or N/A.
	 * @param description
	 */
	protected void storeEventForTimecards(TimedEventType type, TimecardFieldType fieldType, int lineNumber, String description) {
		if (weeklyTimecard != null) {
			TimecardChangeEvent tcChange = new TimecardChangeEvent(getvUser(), type, weeklyTimecard.getId(),
					fieldType, lineNumber, description);
			TimecardChangeEventDAO.getInstance().save(tcChange);
			setTimecardEventList(null);
		}
	}

	/** Method creates a list of Events of currently selected Timecard. */
	public void createTimecardEventList() {
		log.debug("");
		timecardEventList = new ArrayList<>();
		if (weeklyTimecard != null) {
			log.debug("Id of weeklyTimecard = " + weeklyTimecard.getId());
			timecardEventList = TimecardChangeEventDAO.getInstance().findByNamedQuery(TimecardChangeEvent.GET_TIMECARD_CHANGE_EVENT_LIST, map("weeklyTimecardId", weeklyTimecard.getId()));
		}
	}

	public void listenExpenseChange(ValueChangeEvent event) {
		UIData expense = (UIData)event.getComponent().findComponent("expenseTable"); // id of data table in tcExpense
		Integer row = null;
		if (expense != null && weeklyTimecard != null) {
			row = expense.getRowIndex();
			log.debug("field Row no. =" + row);
			List<PayExpense> expenseLineList = new ArrayList<>(weeklyTimecard.getExpenseLines());
			String description = null;
			PayExpense pe = null;
			if (row < expenseLineList.size()) {
				pe = expenseLineList.get(row);
				description = pe.getCategory();
			}

			try {
				if (pe != null) {
					TimecardCheck.validateExpenseItem(pe);
				}
				TimecardCalc.calculateOtherTotals(weeklyTimecard);
			}
			catch(Exception e) {
				EventUtils.logError(e);
				MsgUtils.addGenericErrorMessage();
			}
			// To save timecard events
			if (description != null) {
				checkEventValidity(event, description);
			}
		}
	}

	public void listenPayBreakDownChange(ValueChangeEvent event) {
		try {
			UIData pay = (UIData)event.getComponent().findComponent("cpaybrk"); // id of data table in fulltcPayBreakdown
			if (pay != null && weeklyTimecard != null) {
				int row = pay.getRowIndex();
				log.debug("Row #=" + row);
				if (row < weeklyTimecard.getPayLines().size()) {
					PayBreakdown payBreakdown = weeklyTimecard.getPayLines().get(row);
					String description = payBreakdown.getCategory();
					TimecardCheck.validatePayBreakdown(weeklyTimecard);
					//Calculate all the totals and get the status
					TimecardCalc.calculateOtherTotals(weeklyTimecard);
					// To save timecard events
					checkEventValidity(event, description);
				}
			}
		}
		catch (Exception e) {
			EventUtils.logError(e);
			MsgUtils.addGenericErrorMessage();
		}
	}

	/**
	 * @return True iff the user is currently allowed to edit the Expenses table.
	 */
	public boolean getEditExpense() {
		return getEditHtg() ||
				(getEditRaw() && getPayrollPref() != null && getPayrollPref().getAllowEmployeeExpense());
	}

	/**
	 * @return the "is a Team payroll service" flag based on the current production's
	 * Payroll Service.
	 */
	public boolean isTeamPayroll() {
		if (isTeamPayroll == null) {
			if (viewProduction == null) {
				return false; // return false, but don't set field.
			}
			isTeamPayroll = false;
			viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
			PayrollService payrollService = viewProduction.getPayrollPref().getPayrollService();
			if (payrollService != null) {
				isTeamPayroll = payrollService.getTeamPayroll();
			}
		}
		return isTeamPayroll;
	}

	/**
	 * @return the "is a 'Hybrid' production" flag based on the current production's
	 * payroll preference setting.
	 */
	public boolean isHybridProduction() {
		if (isHybridProduction == null) {
			isHybridProduction = false;
			if (viewProduction != null) { // LS-4422
				viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
				isHybridProduction = viewProduction.getPayrollPref().getIncludeTouring();
			}
		}
		return isHybridProduction;
	}

	/**
	 * The subclass must implement this to provide access to the data for the
	 * left-hand list on the JSP page.
	 *
	 * @see com.lightspeedeps.web.view.ListView#getItemList()
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public List getItemList() {
		return new ArrayList<WeeklyTimecard>();
	}

	/** See {@link #weeklyTimecard}. */
	public WeeklyTimecard getWeeklyTimecard() {
		return weeklyTimecard;
	}
	/** See {@link #weeklyTimecard}. */
	public void setWeeklyTimecard(WeeklyTimecard weeklyTimecard) {
		this.weeklyTimecard = weeklyTimecard;
		approverName = null;
	}

	/**See {@link #notInProduction}. */
	public boolean getNotInProduction() {
		return notInProduction;
	}
	/**See {@link #notInProduction}. */
	public void setNotInProduction(boolean notInProduction) {
		this.notInProduction = notInProduction;
	}

	/** See {@link #editRaw}. */
	public boolean getEditRaw() {
		return editRaw;
	}

	/** See {@link #editHtg}. */
	public boolean getEditHtg() {
		return editHtg;
	}

	/** See {@link #showPrivate}. */
	public boolean getShowPrivate() {
		return showPrivate;
	}
	/** See {@link #showPrivate}. */
	public void setShowPrivate(boolean showPrivate) {
		this.showPrivate = showPrivate;
	}

	/** See {@link #showCopyPrior}. */
	public Boolean getShowCopyPrior() {
		if (showCopyPrior == null) {
			showCopyPrior = calculateShowCopyPrior();
		}
		return showCopyPrior;
	}
	/** See {@link #showCopyPrior}. */
	public void setShowCopyPrior(Boolean showCopyPrior) {
		this.showCopyPrior = showCopyPrior;
	}

	/** See {@link #authBean}. */
	public AuthorizationBean getAuthBean() {
		return authBean;
	}

	/** See {@link #mayApprove}. */
	public boolean getMayApprove() {
		return mayApprove;
	}
	/** See {@link #mayApprove}. */
	public void setMayApprove(boolean mayApprove) {
		this.mayApprove = mayApprove;
	}

	/** See {@link #approvalAuth}. */
	public boolean getApprovalAuth() {
		return approvalAuth;
	}
	/** See {@link #approvalAuth}. */
	public void setApprovalAuth(boolean approvalAuth) {
		this.approvalAuth = approvalAuth;
	}

	/** See {@link #userHasEditHtg}. */
	public boolean getUserHasEditHtg() {
		return userHasEditHtg;
	}
	/** See {@link #userHasEditHtg}. */
	public void setUserHasEditHtg(boolean userHasEditHtg) {
		this.userHasEditHtg = userHasEditHtg;
	}

	/**See {@link #userHasViewHtg}. */
	public boolean getUserHasViewHtg() {
		return userHasViewHtg;
	}

	/**See {@link #userHasViewHtg}. */
	public void setUserHasViewHtg(boolean userHasViewHtg) {
		this.userHasViewHtg = userHasViewHtg;
	}

	/** See {@link #editAuth}. */
	public boolean getEditAuth() {
		return editAuth;
	}
	/** See {@link #editAuth}. */
	public void setEditAuth(boolean editAuth) {
		this.editAuth = editAuth;
	}

	/**See {@link #cloneAuth}. */
	public boolean getCloneAuth() {
		return cloneAuth;
	}
	/**See {@link #cloneAuth}. */
	public void setCloneAuth(boolean cloneAuth) {
		this.cloneAuth = cloneAuth;
	}

	/** See {@link #pullAuth}. */
	public boolean getPullAuth() {
		return pullAuth;
	}
	/** See {@link #pullAuth}. */
	public void setPullAuth(boolean pullAuth) {
		this.pullAuth = pullAuth;
	}

	/** See {@link #recallAuth}. */
	public boolean getRecallAuth() {
		return recallAuth;
	}
	/** See {@link #recallAuth}. */
	public void setRecallAuth(boolean recallAuth) {
		this.recallAuth = recallAuth;
	}

	/**See {@link #viewProductionId}. */
	public Integer getViewProductionId() {
		return viewProductionId;
	}
	/**See {@link #viewProductionId}. */
	public void setViewProductionId(Integer viewProductionId) {
		this.viewProductionId = viewProductionId;
	}

	/**See {@link #viewProduction}. */
	public Production getViewProduction() {
		if (viewProduction != null) {
			viewProduction = ProductionDAO.getInstance().refresh(viewProduction);
			viewProduction.setPayrollPref(PayrollPreferenceDAO.getInstance().refresh(viewProduction.getPayrollPref()));
			viewProduction.getPayrollPref().setPayrollService(PayrollServiceDAO.getInstance().refresh(viewProduction.getPayrollPref().getPayrollService()));
		}
		return viewProduction;
	}
	/**See {@link #viewProduction}. */
	public void setViewProduction(Production viewProduction) {
		this.viewProduction = viewProduction;
	}

//	/** See {@link #occupationList}. */
//	public List<SelectItem> getOccupationList() {
//		if (occupationList == null) {
//			createOccupationList(tcUser);
//		}
//		return occupationList;
//	}
//	/** See {@link #occupationList}. */
//	public void setOccupationList(List<SelectItem> list) {
//		occupationList = list;
//	}

	/** See {@link #viewProject}. */
	public Project getViewProject() {
		return viewProject;
	}
	/** See {@link #viewProject}. */
	public void setViewProject(Project viewProject) {
		this.viewProject = viewProject;
	}

	/** See {@link #commProject}. */
	public Project getCommProject() {
		return commProject;
	}
	/** See {@link #commProject}. */
	public void setCommProject(Project commProject) {
		this.commProject = commProject;
	}

	/** See {@link #tcUser}. */
	public User getTcUser() {
		return tcUser;
	}
	/** See {@link #tcUser}. */
	public void setTcUser(User user) {
		tcUser = user;
	}

	/** See {@link #userId}. */
	public Integer getUserId() {
		return userId;
	}
	/** See {@link #userId}. */
	public void setUserId(Integer userId) {
		this.userId = userId;
	}

	/** See {@link #deleteMileageIx}. */
	public int getDeleteMileageIx() {
		return deleteMileageIx;
	}
	/** See {@link #deleteMileageIx}. */
	public void setDeleteMileageIx(int deleteMileageIx) {
		this.deleteMileageIx = deleteMileageIx;
	}

	/** See {@link #approverName}. */
	public String getApproverName() {
		if (approverName == null) {
			User user = ApproverUtils.findApproverUser(weeklyTimecard);
			if (user != null) {
				approverName = user.getFirstNameLastName();
				approverEmail = user.getEmailAddress();
			}
		}
		return approverName;
	}
	/** See {@link #approverName}. */
	public void setApproverName(String approverName) {
		this.approverName = approverName;
	}

	/** See {@link #approverEmail}. */
	public String getApproverEmail() {
		if (approverEmail == null) {
			User user = ApproverUtils.findApproverUser(weeklyTimecard);
			if (user != null) {
				approverName = user.getFirstNameLastName();
				approverEmail = user.getEmailAddress();
			}
		}
		return approverEmail;
	}
	/** See {@link #approverEmail}. */
	public void setApproverEmail(String approverEmail) {
		this.approverEmail = approverEmail;
	}

	/** See {@link #newComment}. */
	public String getNewComment() {
		return newComment;
	}
	/** See {@link #newComment}. */
	public void setNewComment(String newComment) {
		this.newComment = newComment;
	}

	/**See {@link #newPrivateComment}. */
	public String getNewPrivateComment() {
		return newPrivateComment;
	}
	/**See {@link #newPrivateComment}. */
	public void setNewPrivateComment(String newPrivateComment) {
		this.newPrivateComment = newPrivateComment;
	}

	/** See {@link #newBoxComment}. */
	public String getNewBoxComment() {
		return newBoxComment;
	}
	/** See {@link #newBoxComment}. */
	public void setNewBoxComment(String newBoxComment) {
		this.newBoxComment = newBoxComment;
	}

	/** See {@link #newMileageComment}. */
	public String getNewMileageComment() {
		return newMileageComment;
	}
	/** See {@link #newMileageComment}. */
	public void setNewMileageComment(String newMileageComment) {
		this.newMileageComment = newMileageComment;
	}

	/** See {@link #submitMsg}. */
	public String getSubmitMsg() {
		return submitMsg;
	}
	/** See {@link #submitMsg}. */
	public void setSubmitMsg(String submitMsg) {
		this.submitMsg = submitMsg;
	}

	/** See {@link #showChangePin}. */
	public boolean getShowChangePin() {
		return showChangePin;
	}
	/** See {@link #showChangePin}. */
	public void setShowChangePin(boolean showChangePin) {
		this.showChangePin = showChangePin;
	}

	/**See {@link #showClone}. */
	public boolean getShowClone() {
		return showClone;
	}
	/**See {@link #showClone}. */
	public void setShowClone(boolean showClone) {
		this.showClone = showClone;
	}

	/** See {@link #showReject}. */
	public boolean getShowReject() {
		return showReject;
	}
	/** See {@link #showReject}. */
	public void setShowReject(boolean showReject) {
		this.showReject = showReject;
	}

	/**
	 * @return True if the "Travel/Work legend" should be displayed on the basic
	 *         and full timecard pages.
	 */
	public boolean getShowTwLegend() {
		return calculateShowLegend(DayType.TW);
	}

	/**
	 * @return True if the "Work/Travel legend" should be displayed on the basic
	 *         and full timecard pages.
	 */
	public boolean getShowWtLegend() {
		return calculateShowLegend(DayType.WT);
	}

	/** See {@link #showCreate}. */
	public boolean getShowCreate() {
		return showCreate;
	}
	/** See {@link #showCreate}. */
	public void setShowCreate(boolean showCreate) {
		this.showCreate = showCreate;
	}

	/** See {@link #startFormId}. */
	public Integer getStartFormId() {
		return startFormId;
	}
	/** See {@link #startFormId}. */
	public void setStartFormId(Integer startFormId) {
		this.startFormId = startFormId;
	}

	/**See {@link #deleteExpenseIx}. */
	public int getDeleteExpenseIx() {
		return deleteExpenseIx;
	}
	/**See {@link #deleteExpenseIx}. */
	public void setDeleteExpenseIx(int deleteExpenseIx) {
		this.deleteExpenseIx = deleteExpenseIx;
	}

	/** See {@link #expCategoryDL}. */
	public List<SelectItem> getExpCategoryDL() {
		if (expCategoryDL == null) {
			expCategoryDL = createExpCategoryDL();
		}
		return expCategoryDL;
	}

	/** See {@link #emplExpCategoryDL}. */
	public List<SelectItem> getEmplExpCategoryDL() {
		if (emplExpCategoryDL == null) {
			emplExpCategoryDL = createEmplExpCategoryDL();
		}
		return emplExpCategoryDL;
	}

	/**See {@link #expCategory}. */
	public PayCategory getExpCategory() {
		return expCategory;
	}
	/**See {@link #expCategory}. */
	public void setExpCategory(PayCategory expCategory) {
		this.expCategory = expCategory;
	}

	/** See {@link com.lightspeedeps.web.util.EnumList#dayTypeList}. */
	public List<SelectItem> getDayTypeDL() {
		if (dayTypeExemptList != null && ! dayTypeExemptList.isEmpty()) {
			return dayTypeExemptList; // LS-2189
		}
		else if (hasTouringRates) {
			if (isHybridProduction()) { // LS-2160
				return dayTypeHybridToursList;
			}
			else {
				return dayTypeToursList;
			}
		}
		else if (isHybridProduction()) { // LS-2160
			return dayTypeHybridList;
		}
		else if (getUseModelRelease()) { //LS-4589
			return dayTypeModelList;
		}
		else if (isTeamPayroll() && weeklyTimecard.isNonUnion()) { // LS-2010
			return dayTypeNonUnionList;
		}

		return EnumList.getDayTypeList();
	}

	/** See {@link com.lightspeedeps.web.util.EnumList#workZoneList}. */
	public List<SelectItem> getWorkZoneDL() {
		return EnumList.getWorkZoneList();
	}

	public boolean getShowOccupationDL() {
		return (occupationDL != null && occupationDL.size() > 1);
	}

	/** See {@link #occupationDL}. */
	public List<SelectItem> getOccupationDL() {
		return occupationDL;
	}
	/** See {@link #occupationDL}. */
	public void setOccupationDL(List<SelectItem> occupationDL) {
		this.occupationDL = occupationDL;
	}

	/** See {@link #weekEndDay}. */
	public Integer getWeekEndDay() {
		if (weekEndDay == null) {
			weekEndDay = TimecardUtils.findWeekEndDay();
		}
		return weekEndDay;
	}
	/** See {@link #weekEndDay}. */
	public void setWeekEndDay(Integer weekEndDay) {
		this.weekEndDay = weekEndDay;
	}

	/** See {@link #weekEndDate}. */
	public Date getWeekEndDate() {
		return weekEndDate;
	}
	/** See {@link #weekEndDate}. */
	public void setWeekEndDate(Date createDate) {
		weekEndDate = createDate;
	}

	/** See {@link #weekEndDateDL}. */
	public List<SelectItem> getWeekEndDateDL() {
		return weekEndDateDL;
	}
	/** See {@link #weekEndDateDL}. */
	public void setWeekEndDateDL(List<SelectItem> createDateDL) {
		weekEndDateDL = createDateDL;
	}

	/**See {@link #weeklyTimecardDAO}. */
	protected WeeklyTimecardDAO getWeeklyTimecardDAO() {
		if (weeklyTimecardDAO == null) {
			weeklyTimecardDAO = WeeklyTimecardDAO.getInstance();
		}
		return weeklyTimecardDAO;
	}

	/** See {@link #productionDAO}. */
	protected ProductionDAO getProductionDAO() {
		if(productionDAO == null) {
			productionDAO = ProductionDAO.getInstance();
		}
		return productionDAO;
	}

	/** See {@link #timecardEventList}. */
	public List<TimecardChangeEvent> getTimecardEventList() {
		if (timecardEventList == null &&
				HeaderViewBean.getInstance().getMiniTab() == TAB_AUDIT) {
			// Only bother to create it if we're on the audit display mini-tab
			createTimecardEventList();
		}
		return timecardEventList;
	}
	/** See {@link #timecardEventList}. */
	public void setTimecardEventList(List<TimecardChangeEvent> timecardEventList) {
		this.timecardEventList = timecardEventList;
	}

	@Override
	public void setSelectedTab(int n) {
		log.debug("Selected tab = " + n);
		if (weeklyTimecard != null) {
//			weeklyTimecard = getWeeklyTimecardDAO().refresh(weeklyTimecard);
			if (n == TAB_TC_ATTACHMENTS) {
				log.debug("");
				List<Attachment> list = getAttachmentBean().getAttachmentList();
				if (list == null || list.size() == 0) {
					log.debug("");
					n = 0;
				}
				else {
					log.debug("");
					Integer id = SessionUtils.getInteger(Constants.ATTR_TIMECARD_ATTACHMENT_ID);
					if (id != null) {
						log.debug("");
						getAttachmentBean().previewAttachment(AttachmentDAO.getInstance().findById(id));
					}
					else {
						log.debug("");
						getAttachmentBean().previewAttachment(list.get(0));
					}
				}
			}
		}
		super.setSelectedTab(n);
	}

	/** Utility method
	 * @return AttachmentBean instance
	 */
	public AttachmentBean getAttachmentBean() {
		if (attachmentbean == null) {
			attachmentbean = AttachmentBean.getInstance();
		}
		return attachmentbean;
	}

	/**
	 * method to set default timesheet city/state according to daytype and
	 * country code - LS-2161
	 *
	 * @param dailyTime
	 */
	protected void setDefaultCityState(DailyTime dailyTime) {
		DayType dt = dailyTime.getDayType();
		if (dailyTime.getCountry() == null) {
			dailyTime.setCountry("US");
		}

		//LS-2313 changes according to timecard State/City (in hybrid productions only) conversion rules are according to the revised spreadsheet
		if(dt != null) {
			if (dt.isUsCityStateRequired()) { // TSH,  HOW,  WK,  OV
				// Show(T), Work(T), Work
				if (! dailyTime.getCountry().equals(Constants.DEFAULT_COUNTRY_CODE)) {
					dailyTime.setState(Constants.FOREIGN_OT_STATE);
					dailyTime.setCity(null);
				}
				else {
					// If coming from a foreign country, set the state to null
					// to remove the OT selection.
					String touringState = dailyTime.getState();
					if(touringState != null && touringState.equals(Constants.FOREIGN_OT_STATE)) {
						dailyTime.setState(null);
					}
				}
			}
			else if (dt.equals(DayType.TPR) || dt.equals(DayType.TPO)) {
				// LS-2313 For Prep and Post force HM regardless of country selected.
				dailyTime.setState(Constants.TOURS_HOME_STATE);
				dailyTime.setCity(null);
			}
			else if(dt.equals(DayType.TR) ||
					dt.equals(DayType.TTR) || dt.equals(DayType.TDO) || dt.equals(DayType.HOO)) {
				// Travel, Travel(T), Down(T), Off(T)
				dailyTime.setCity(null);
				if (! dailyTime.getCountry().equals(Constants.DEFAULT_COUNTRY_CODE)) {
					dailyTime.setState(Constants.FOREIGN_OT_STATE);
				}
				else {
					dailyTime.setState(Constants.TOURS_HOME_STATE);
				}
			}
			else if (dt.isCityRequiredStateHM()) {
				// Sick Paid, HoliPaid, Vacation, PTO Paid
				// LS-2313 Always set to HM and US.
				dailyTime.setState(Constants.TOURS_HOME_STATE);
				dailyTime.setCountry(Constants.DEFAULT_COUNTRY_CODE);
			}
		}
		else {
			// Day Type does not have a value reset state value depending on the timecard country selected
			if (dailyTime.getCountry().equals(Constants.DEFAULT_COUNTRY_CODE)) {
				dailyTime.setState(weeklyTimecard.getStateWorked());
				if (FF4JUtils.useFeature(FeatureFlagType.TTCO_RESIDENT_COMMERCIAL_TIMECARDS)) {
					dailyTime.setCity(weeklyTimecard.getCityWorked());
					if (dailyTime.getState() != null) {
						try {
							cityDL(dailyTime);
						}
						catch (JSONException e) {
							EventUtils.logError(e);
							MsgUtils.addGenericErrorMessage();
						}
					}
				}
			}
			else {
				dailyTime.setState(Constants.FOREIGN_OT_STATE);
			}
		}
	}

	/**
	 * This method is called from JSF for the State column selectItems. commonly
	 * used for IndivTimecardBean and FullTimecardBean LS-2470. The list
	 * returned varies with the production type and the country specified (if
	 * any). See {@link #STATE_LIST_STD}, {@link #STATE_LIST_HYBRID},
	 * {@link #STATE_LIST_TOUR}, and {@link #STATE_LIST_HM_OT}.
	 * <p>
	 * LS-1591: Don't allow "HM" (which is only in the {@link #STATE_LIST_TOUR}
	 * for Worked day types.
	 */
	public List<SelectItem> stateCodeTypeDL(DailyTime dt) {
		DayType type = dt.getDayType();
		List<SelectItem> list = STATE_LIST_STD;
		String country = dt.getCountry();
		if (country != null && ! Constants.DEFAULT_COUNTRY_CODE.equals(country)) {
			list = STATE_LIST_HM_OT; // LS-2331
		}
		else if (isHybridProduction()) {
			list = STATE_LIST_HYBRID;
			if (type != null) {
				if (type.isStateDisabled()) {
					// For this dayType, state is forced to HM or OT & disabled.
					list = STATE_LIST_HM_OT; // LS-2331
				}
				else if (type != DayType.WK && type != DayType.HOW &&
						getWeeklyTimecard().getStartForm() != null &&
						getWeeklyTimecard().getStartForm().getHasTourRates()) {
					list = STATE_LIST_TOUR;
				}

			}


		}
		return list;
	}

	/**  state onchange for IndivTimecardBean and  FullTimecardBean LS-2470 */
	public void listenDailyStateChange(ValueChangeEvent event) {
		try {
			if (FF4JUtils.useFeature(FeatureFlagType.TTCO_RESIDENT_COMMERCIAL_TIMECARDS)) {
				String stateNew = event.getNewValue().toString();
				String stateOld = event.getOldValue().toString();
				DailyTime currentRow =
						(DailyTime)event.getComponent().getAttributes().get("stateRow");
				if (stateOld != null && ! stateNew.equals(stateOld)) {
					currentRow.setCity(null);
				}
				if (! StringUtils.isEmpty(stateNew)) {
					cityDL(currentRow);
				}
				else {
					currentRow.setCities(null);
				}
			}
			//LS-2472 getting new value for state
			if(isHybridProduction()) {
				DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
				setDefaultCityState(dailyTime);
			}
		}
		catch(Exception ex) {
			log.debug(ex);
		}
	}

	/** city onchange for IndivTimecardBean and FullTimecardBean LS-2470 */
	public void listenDailyCityChange(ValueChangeEvent event) {
		try {
			String cityNew = event.getNewValue().toString();
			String cityOld = event.getOldValue().toString();
			DailyTime currentRow = (DailyTime)event.getComponent().getAttributes().get("cityRow");
			if (currentRow != null && cityOld != null && ! cityNew.equals(cityOld)) {
				currentRow.setCity(cityNew);
			}
			//LS-2472 getting new value for state
			if (isHybridProduction()) {
				DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
				setDefaultCityState(dailyTime);
			}
		}
		catch (Exception ex) {
			log.debug(ex);
		}
	}
	/** country onchange for IndivTimecardBean and  FullTimecardBean LS-2470 */
	public void listenDailyCountryChange(ValueChangeEvent event) {
		try {
			if(isHybridProduction()) {
				DailyTime dailyTime = (DailyTime)ServiceFinder.getManagedBean("dailyTime");
				setDefaultCityState(dailyTime);
			}
		}
		catch(Exception ex) {
			log.debug(ex);
		}
	}

	/** See {@link #useModelRelease}. LS-4651 */
	public Boolean getUseModelRelease() {
		if (useModelRelease == null) {
			useModelRelease = false;
			if (weeklyTimecard != null && weeklyTimecard.getStartForm() != null &&
					weeklyTimecard.getStartForm().getModelRelease() != null &&
					FF4JUtils.useFeature(FeatureFlagType.TTCO_MRF_STARTS_AND_TIMECARDS)) {
				useModelRelease = true;
			}
		}
		return useModelRelease;
	}

	/** See {@link #useModelRelease}. LS-4651 */
	public FormModelRelease getModelRelease() {
		if (modelRelease == null && getUseModelRelease()) {
			Integer mrId = weeklyTimecard.getStartForm().getModelRelease().getId();
			if (mrId != null) {
				modelRelease = (FormModelRelease)FormService.getInstance().findById(mrId,
						PayrollFormType.MODEL_RELEASE.getApiFindUrl(), FormModelRelease.class);
			}
		}
		return modelRelease;
	}

	/** See {@link #teamPayroll}. */
	public Boolean getTeamPayroll() {
		if (teamPayroll == null) {
			isTeamPayroll = false;
			PayrollPreference pf = getViewProduction().getPayrollPref();
			if(pf.getPayrollService() != null) {
				isTeamPayroll =  pf.getPayrollService().getTeamPayroll();
			}
		}
		return isTeamPayroll;
	}

	/**
	 * method to get the city list based on the state
	 *
	 * @param state
	 * @throws JSONException
	 */
	public List<SelectItem> cityDL(DailyTime dt) throws JSONException {
		JSONArray cityByState = LocationUtils.getCityByState(dt.getState());
		setDisplayCities(false);
		List<SelectItem> citiesList = null;
		if (null != cityByState) {
			citiesList = LocationUtils.getCityListBystate(cityByState);
			if (citiesList != null) {
				citiesList.add(Constants.SELECT_OTHER_ITEM);
				dt.setCities(citiesList);
				setDisplayCities(true);
				return citiesList;
			}
		}
		return citiesList;
	}

	/**
	 * method to get the city list based on the state
	 *
	 * @param state
	 * @throws JSONException
	 */
	public List<SelectItem> cityWt(WeeklyTimecard wt) throws JSONException {
		JSONArray cityByState = LocationUtils.getCityByState(wt.getStateWorked());
		setDisplayCities(false);
		List<SelectItem> citiesList = null;
		if (null != cityByState) {
			citiesList = LocationUtils.getCityListBystate(cityByState);
			if (citiesList != null) {
				citiesList.add(Constants.SELECT_OTHER_ITEM);
				wt.setCities(citiesList);
				setDisplayCities(true);
				return citiesList;
			}
		}
		return citiesList;
	}

	public boolean getDisplayCities() {
		return displayCities;
	}

	public void setDisplayCities(boolean displayCities) {
		this.displayCities = displayCities;
	}




}
