/* LightSPEED JavaScript functions for both desktop and mobile pages. */

// * * * Setup our own error handling to supercede ICEfaces pop-up errors * * *  (rev 2.1.3916)
/*
// Assign our error handling function (for ICEfaces override) to a variable
var iceErrorCallback = function iceHandleError(statusCode, responseTxt, responseDOM) {
	console.log("code=" + statusCode);
	console.log("text=" + responseTxt);
	// Handle all errors by simply redirecting to an error page
	window.location.href = ice_error_url;
};
// Safely check if ICEfaces is available
try {
	if (ice) {
		// Turn off the popups as we plan to handle this ourselves
		ice.configuration.disableDefaultIndicators = true;
	
		// Register our error handler as a callback
		ice.onServerError(iceErrorCallback);
	}
}
catch(e) {
	console.log('error: ' + e);
}
*/
function resize() {
	// supply this function in case the page doesn't.
}

//***** Session Timeout Warning and Redirect ***** //
var sess_timeout = 20 /* minutes */ * 60 * 1000;  // Session timeout in milliseconds
var sess_polling = 60 /* seconds */ * 1000; // polling interval in milliseconds
var sess_lastActivity = new Date(); // Time of last user interaction

// var sess_logout_uri = ''; /* specified separately in desktop and mobile javascript files */

function sessionInitTimer() {
	//show_warning = true;
	sess_lastActivity = new Date();
	document.body.onmouseup = function() {sessionResetTimer();};
	document.body.onkeypress = function() {sessionResetTimer();};
	sessionCheckStatus(); // will set timer for next timeout check
}

/**
 * Reset the activity time -- this should be called upon any user activity.
 */
function sessionResetTimer() {
	sess_lastActivity = new Date();
	//show_warning = true;
}

/**
 * Check if we have reached the timeout limit, and log the user off if so.
 */
function sessionCheckStatus() {
	now = new Date().getTime();
	console.log('test timeout ' + sess_lastActivity);
	// Warning code not used - if 'alert' is up, javascript stops and user will never get logged out.
//    if (now > (sess_lastActivity + warn_sec) && now < (sess_lastActivity + sess_timeout) && show_warning) {
//        console.log('warning reached');
//        show_warning = false; //Don't show again
//        setTimeout("CheckSessionStatus();", sess_polling);
//        alert("Your session will timeout in " + Math.round((timeout_sec - warn_sec) / 60000) +
//        		" minutes, please click a button or navigate to another page before it expires.");
//        epoch = new Date().getTime();
//    }
//    else
	if (now >= sess_lastActivity.getTime() + sess_timeout) {
		console.log('timeout reached');
		window.location.href = sess_logout_uri;
	}
	else {
		setTimeout("sessionCheckStatus();", sess_polling);
	}
}

/**
 * Do an ice.submit using the supplied event, and the named document element.
 * @param event is the event (typically a keystroke) that triggered this call.
 * @param id is the name of the element to submit upon (i.e., click).
 * 
 * An example of using this (from the login page):
 * <br/>
 * 	< h:body onkeyup="if (event.keyCode==13) { lSubmit(event,'loginForm:login'); };" >
 */
function lSubmit(event,id) {
	try {
		//console.log("lSubmit, id=" + id);
		obj = document.getElementById(id);
		if (obj != null) {
			//console.log('submitting event on: ' + obj);
			ice.submit(event, obj);
		}
		else {
			console.log('element id not found: ' + id);
		}
	} 
	catch (e) {
		console.log('lSubmit error:' + e + "; id=" + id);
	}
}

/**
 * Click the button identified by 'id'.
 * (desktop: Installed for breakdownsheetsedit.jsp, Add Element pop-up.)
 * (mobile: used in daysInfo.xhtml)
 * @param id The component id -- usually of the style "formname:component-id".
 */
function clickBtn(id) {
	try {
		obj = document.getElementById(id + '_link'); // ICEfaces v4 ace:linkButton
		console.log("clickbtn, obj=" + obj);
		alert("Change clickBtn call to lSubmit?? See script_common.uc.js:lSubmit()");
		if (obj == null) {
			obj = document.getElementById(id + '_span-button'); // ICEfaces v3 ace:linkButton
			if (obj == null) {
				obj = document.getElementById(id); // ICEfaces v3 ice:commandLink
			}
		}
		if (obj != null) {
			console.log('clicking object found: ' + obj);
			obj.click();
		}
		else {
			console.log('element id not found: ' + id);
		}
	} 
	catch (e) {
		console.log('clickBtn error:' + e);
	}
}

var queuedButton = null; // a button clicked by the user
var queuedEvent = null;  // the mouse event generated by the click
var updateWhileQ = 0;	 // how many "update" events have been processed while a button was queued

/**
 * Function designed to be called from ICEfaces onAfterUpdate API.
 * It checks to see if there was a button pressed by the user which
 * never fired.
 * @param updates The update stream just applied on the client.
 */
var checkButton = function(updates) {
	//console.log('checkButton');
	if (queuedButton != null) {
		updateWhileQ++;
		//console.log('after: qd=' + queuedButton.id + ', cnt=' + updateWhileQ);
		if (updateWhileQ > 1) {
			updateWhileQ = 0;
			setTimeout(function() {
				clickQueued();
			}, 0);
		}
	}
	if (checkShowErrorsOn) {
		checkShowErrors(updates);
	}
};

/**
 * A function usually called by the onclick event of a button, to "queue"
 * the click for later execution if it doesn't get generated properly by
 * the framework.  This is part of a fix for an ICEfaces issue where clicking
 * a button once may not trigger the action if the focus is currently on
 * a field with "partialSubmit='true'".  Note that the page must include
 * this javaScript statement:
 *		ice.onAfterUpdate(checkButton);
 *
 * @param button
 * @param evt
 */
function queueClick(button, evt) {
	queuedEvent = {};
	for (var i in evt) {
		queuedEvent[i] = evt[i];
	}
	queuedButton = button;
	//console.log("queue: " + button.id + ", event: " + evt);
}

/**
 * Click the currently "queued" button, if it exists.  After it
 * is clicked, the queued value is set to null, so it can only
 * be clicked once.
 */
function clickQueued() {
	if (queuedButton != null) {
		clickLink(queuedButton, queuedEvent);
		queuedButton = null;
		queuedEvent = null;
	}
}

/**
 * This function is called from the server (by inserting the
 * call in the ICEfaces update stream) to let the client know
 * that a button click (action) was processed during the last
 * cycle.  This causes any "queued" button to be cleared, so
 * we won't try and "click" it in checkButton().
 */
function buttonClicked() {
	//console.log('buttonClicked');
	queuedButton = null;
	queuedEvent = null;
}

/**
 * This function does the same action as clicking an ice:commandLink tag.
 * <p>
 * Example of its use:<br/>
 * < ice:commandLink value="Cancel" action="#{fullTimecardBean.actionCancel}" <br/>
 * 			onclick="return clickLink(this,event);" / >
 *
 * @param element The ice:commandLink HTML element (not the text id).
 * @param evt The event causing the submit.
 * @returns false
 */
function clickLink(element, evt) {
	var frm = formOf(element);
	//console.log("form: " + frm.id);
	//console.log("clickLink: " + element.id);
	//console.log("val: " + frm[frm.id + ':j_idcl'].value);
	frm[frm.id + ':j_idcl'].value = element.id;
	//console.log("val: " + frm[frm.id + ':j_idcl'].value);
	iceSubmit(frm, element, evt);
	//console.log("clickLink: icesubmit done");
	return false;
}

/*
 * The webview function is called by JavaScript code constructed in CustomFormBean.
 *   fileName: the URL that WebViewer will request from the server, expecting to get
 *				back the document to be displayed.
 *	 contactDocId: included by WebViewer in all server requests as the "did" parameter;
 *				the value will be used by LsFacesServlet to find the XFDF content.
 *   docType: should be "xod"; this invokes the "Universal Web Viewer" functionality, which
 *				supports mobile and desktop.  "pdf" may be used for testing in desktop
 *				environment. This parameter determines the type of data that WebViewer expects
 *				to be returned when it requests the file body (using the fileName URL).
 */
var myWebViewer = null;
function webview(fileName, contactDocId, docType) {
	var viewerElement = document.getElementById("viewer");
	console.log('creating WebViewer');

	PDFTron.WebViewer.prototype.isMobileDevice = function() {
		console.log("isMobileDevice: LS forcing mobile=false");
		return false;
	};

	myWebViewer = new PDFTron.WebViewer({
		path: "../../lib",
		type: "html5",
		mobileRedirect: true,
		/*l: "4adxxx...xxxxx", *wrong key; this hangs webViewer */
		enableAnnotations: true,
		enableReadOnlyMode: true, /* prevent user from changing or adding annotations */
		streaming: true,
		initialDoc: fileName,
		documentType: docType, /* "pdf" or "xod" */
		serverUrl: "../../_db_annotations/pws",
		config: "../../js/webViewConfig.js",
		documentId: contactDocId /* included in server requests as "did" parameter */
	}, viewerElement);
	
	// disable WebViewer print feature
	viewerElement.addEventListener('ready', function() {
		const viewerInstance = myWebViewer.getInstance();
		viewerInstance.disablePrint();
		console.log("print disabled");
	});

}

/*
 * Set up the WebViewer instance for an Attachment. Called by JavaScript code constructed
 * in AttachmentBean.
 *   fileName: the URL that WebViewer will request from the server, expecting to get
 *				back the document to be displayed.
 *	 contactDocId: included by WebViewer in all server requests as the "did" parameter;
 *				the value will be used by LsFacesServlet to find the XFDF content.
 *   docType: should be "xod"; this invokes the "Universal Web Viewer" functionality, which
 *				supports mobile and desktop.  "pdf" may be used for testing in desktop
 *				environment. This parameter determines the type of data that WebViewer expects
 *				to be returned when it requests the file body (using the fileName URL).
 */
var myWebViewerAttach = null;
function webviewAttach(fileName, contactDocId, docType) {
	var viewerElement = document.getElementById("attachViewer");
	console.log('creating WebViewer for attachment');

	PDFTron.WebViewer.prototype.isMobileDevice = function() {
		console.log("isMobileDevice: LS forcing mobile=false");
		return false;
	};

	myWebViewerAttach = new PDFTron.WebViewer({
		path: "../../lib",
		type: "html5",
		mobileRedirect: true,
		/*l: "4adxxx...xxxxx", *wrong key; this hangs webViewer */
		enableAnnotations: false,
		enableReadOnlyMode: true, /* prevent user from changing or adding annotations */
		streaming: true,
		initialDoc: fileName,
		documentType: docType, /* "pdf" or "xod" */
		serverUrl: "../../_db_annotations/pws",
		config: "../../js/webViewConfig.js",
		documentId: contactDocId /* included in server requests as "did" parameter */
	}, viewerElement);
	
	// disable WebViewer print feature
	viewerElement.addEventListener('ready', function() {
		const viewerInstance = myWebViewerAttach.getInstance();
		viewerInstance.disablePrint();
		console.log("print disabled for attachment");
	});

}

/*
 * lsSaveAnnotations is called via onclick() settings on the various
 * custom form pages.  This saves the user's updates when they click a
 * Save, Sign, or Initial button on a custom form in Edit mode.
 */
function lsSaveAnnotations() {
	console.log("lsSaveannotations");
	// var iframeWindow = $('#viewer').find('iframe')[0].contentWindow;
	var viewerElement = document.getElementById("viewer");
	if (viewerElement != null) {
		var iframeWindow = viewerElement.children[0];
		console.log("save: viewerElement=" + viewerElement + "; iframe=" + iframeWindow);
		if (iframeWindow != null) {
			iframeWindow.contentWindow.readerControl.saveAnnotations();
		}
	}
}
